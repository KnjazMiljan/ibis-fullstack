/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./resources/js/jquery-3.4.1.js":
/*!**************************************!*\
  !*** ./resources/js/jquery-3.4.1.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * jQuery JavaScript Library v3.4.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2019-05-01T21:04Z\n */\n(function (global, factory) {\n  \"use strict\";\n\n  if (( false ? undefined : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error(\"jQuery requires a window with a document\");\n      }\n\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  } // Pass this if window is not defined yet\n\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n  // enough that all such attempts are guarded in a try block.\n  \"use strict\";\n\n  var arr = [];\n  var document = window.document;\n  var getProto = Object.getPrototypeOf;\n  var _slice = arr.slice;\n  var concat = arr.concat;\n  var push = arr.push;\n  var indexOf = arr.indexOf;\n  var class2type = {};\n  var toString = class2type.toString;\n  var hasOwn = class2type.hasOwnProperty;\n  var fnToString = hasOwn.toString;\n  var ObjectFunctionString = fnToString.call(Object);\n  var support = {};\n\n  var isFunction = function isFunction(obj) {\n    // Support: Chrome <=57, Firefox <=52\n    // In some browsers, typeof returns \"function\" for HTML <object> elements\n    // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n    // We don't want to classify *any* DOM node as a function.\n    return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n  var isWindow = function isWindow(obj) {\n    return obj != null && obj === obj.window;\n  };\n\n  var preservedScriptAttributes = {\n    type: true,\n    src: true,\n    nonce: true,\n    noModule: true\n  };\n\n  function DOMEval(code, node, doc) {\n    doc = doc || document;\n    var i,\n        val,\n        script = doc.createElement(\"script\");\n    script.text = code;\n\n    if (node) {\n      for (i in preservedScriptAttributes) {\n        // Support: Firefox 64+, Edge 18+\n        // Some browsers don't support the \"nonce\" property on scripts.\n        // On the other hand, just using `getAttribute` is not enough as\n        // the `nonce` attribute is reset to an empty string whenever it\n        // becomes browsing-context connected.\n        // See https://github.com/whatwg/html/issues/2369\n        // See https://html.spec.whatwg.org/#nonce-attributes\n        // The `node.getAttribute` check was added for the sake of\n        // `jQuery.globalEval` so that it can fake a nonce-containing node\n        // via an object.\n        val = node[i] || node.getAttribute && node.getAttribute(i);\n\n        if (val) {\n          script.setAttribute(i, val);\n        }\n      }\n    }\n\n    doc.head.appendChild(script).parentNode.removeChild(script);\n  }\n\n  function toType(obj) {\n    if (obj == null) {\n      return obj + \"\";\n    } // Support: Android <=2.3 only (functionish RegExp)\n\n\n    return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : _typeof(obj);\n  }\n  /* global Symbol */\n  // Defining this global in .eslintrc.json would create a danger of using the global\n  // unguarded in another place, it seems safer to define global only for this module\n\n\n  var version = \"3.4.1\",\n      // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    // Need init if jQuery is called (just allow error to be thrown if not included)\n    return new jQuery.fn.init(selector, context);\n  },\n      // Support: Android <=4.0 only\n  // Make sure we trim BOM and NBSP\n  rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n    constructor: jQuery,\n    // The default length of a jQuery object is 0\n    length: 0,\n    toArray: function toArray() {\n      return _slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      // Return all the elements in a clean array\n      if (num == null) {\n        return _slice.call(this);\n      } // Return just the one element from the set\n\n\n      return num < 0 ? this[num + this.length] : this[num];\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    each: function each(callback) {\n      return jQuery.each(this, callback);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    slice: function slice() {\n      return this.pushStack(_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    end: function end() {\n      return this.prevObject || this.constructor();\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  };\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target; // Skip the boolean and the target\n\n      target = arguments[i] || {};\n      i++;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (_typeof(target) !== \"object\" && !isFunction(target)) {\n      target = {};\n    } // Extend jQuery itself if only one argument is passed\n\n\n    if (i === length) {\n      target = this;\n      i--;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          copy = options[name]; // Prevent Object.prototype pollution\n          // Prevent never-ending loop\n\n          if (name === \"__proto__\" || target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n            src = target[name]; // Ensure proper type for the source value\n\n            if (copyIsArray && !Array.isArray(src)) {\n              clone = [];\n            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\n              clone = {};\n            } else {\n              clone = src;\n            }\n\n            copyIsArray = false; // Never move original objects, clone them\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    noop: function noop() {},\n    isPlainObject: function isPlainObject(obj) {\n      var proto, Ctor; // Detect obvious negatives\n      // Use toString instead of jQuery.type to catch host objects\n\n      if (!obj || toString.call(obj) !== \"[object Object]\") {\n        return false;\n      }\n\n      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain\n\n      if (!proto) {\n        return true;\n      } // Objects with prototype are plain iff they were constructed by a global Object function\n\n\n      Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n      return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    // Evaluates a script in a global context\n    globalEval: function globalEval(code, options) {\n      DOMEval(code, {\n        nonce: options && options.nonce\n      });\n    },\n    each: function each(obj, callback) {\n      var length,\n          i = 0;\n\n      if (isArrayLike(obj)) {\n        length = obj.length;\n\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      }\n\n      return obj;\n    },\n    // Support: Android <=4.0 only\n    trim: function trim(text) {\n      return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\n    },\n    // Support: Android <=4.0 only, PhantomJS 1 only\n    // push.apply(_, arraylike) throws on ancient WebKit\n    merge: function merge(first, second) {\n      var len = +second.length,\n          j = 0,\n          i = first.length;\n\n      for (; j < len; j++) {\n        first[i++] = second[j];\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, invert) {\n      var callbackInverse,\n          matches = [],\n          i = 0,\n          length = elems.length,\n          callbackExpect = !invert; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n\n      return matches;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var length,\n          value,\n          i = 0,\n          ret = []; // Go through the array, translating each of the items to their new values\n\n      if (isArrayLike(elems)) {\n        length = elems.length;\n\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return concat.apply([], ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  });\n\n  if (typeof Symbol === \"function\") {\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n  } // Populate the class2type map\n\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArrayLike(obj) {\n    // Support: real iOS 8.2 only (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && \"length\" in obj && obj.length,\n        type = toType(obj);\n\n    if (isFunction(obj) || isWindow(obj)) {\n      return false;\n    }\n\n    return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n  }\n\n  var Sizzle =\n  /*!\n  * Sizzle CSS Selector Engine v2.3.4\n  * https://sizzlejs.com/\n  *\n  * Copyright JS Foundation and other contributors\n  * Released under the MIT license\n  * https://js.foundation/\n  *\n  * Date: 2019-04-08\n  */\n  function (window) {\n    var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        // Instance-specific data\n    expando = \"sizzle\" + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        nonnativeSelectorCache = createCache(),\n        sortOrder = function sortOrder(a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n      }\n\n      return 0;\n    },\n        // Instance methods\n    hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        push_native = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf as it's faster than native\n    // https://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function indexOf(list, elem) {\n      var i = 0,\n          len = list.length;\n\n      for (; i < len; i++) {\n        if (list[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        // Regular expressions\n    // http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n    \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n        pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    // 1. quoted (capture 3; capture 4 or capture 5)\n    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n    \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n    \".*\" + \")\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n        rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n        rdescend = new RegExp(whitespace + \"|>\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n      \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rhtml = /HTML$/i,\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n        // CSS escapes\n    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n        funescape = function funescape(_, escaped, escapedWhitespace) {\n      var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n      // Support: Firefox<24\n      // Workaround erroneous numeric interpretation of +\"0x\"\n\n      return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n      String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    },\n        // CSS string/identifier serialization\n    // https://drafts.csswg.org/cssom/#common-serializing-idioms\n    rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n        fcssescape = function fcssescape(ch, asCodePoint) {\n      if (asCodePoint) {\n        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n        if (ch === \"\\0\") {\n          return \"\\uFFFD\";\n        } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n        return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n      } // Other potentially-special ASCII characters get backslash-escaped\n\n\n      return \"\\\\\" + ch;\n    },\n        // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function unloadHandler() {\n      setDocument();\n    },\n        inDisabledFieldset = addCombinator(function (elem) {\n      return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n    }, {\n      dir: \"parentNode\",\n      next: \"legend\"\n    }); // Optimize for push.apply( _, NodeList )\n\n\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n      // Detect silently failing push.apply\n\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = {\n        apply: arr.length ? // Leverage slice if possible\n        function (target, els) {\n          push_native.apply(target, slice.call(els));\n        } : // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n              i = 0; // Can't trust NodeList.length\n\n          while (target[j++] = els[i++]) {}\n\n          target.length = j - 1;\n        }\n      };\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var m,\n          i,\n          elem,\n          nid,\n          match,\n          groups,\n          newSelector,\n          newContext = context && context.ownerDocument,\n          // nodeType defaults to 9, since context defaults to document\n      nodeType = context ? context.nodeType : 9;\n      results = results || []; // Return early from calls with invalid selector or context\n\n      if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return results;\n      } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n      if (!seed) {\n        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n          setDocument(context);\n        }\n\n        context = context || document;\n\n        if (documentIsHTML) {\n          // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n          // (excepting DocumentFragment context, where the methods don't exist)\n          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n            // ID selector\n            if (m = match[1]) {\n              // Document context\n              if (nodeType === 9) {\n                if (elem = context.getElementById(m)) {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } else {\n                  return results;\n                } // Element context\n\n              } else {\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } // Type selector\n\n            } else if (match[2]) {\n              push.apply(results, context.getElementsByTagName(selector));\n              return results; // Class selector\n            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n              push.apply(results, context.getElementsByClassName(m));\n              return results;\n            }\n          } // Take advantage of querySelectorAll\n\n\n          if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only\n          // Exclude object elements\n          nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\")) {\n            newSelector = selector;\n            newContext = context; // qSA considers elements outside a scoping root when evaluating child or\n            // descendant combinators, which is not what we want.\n            // In such cases, we work around the behavior by prefixing every selector in the\n            // list with an ID selector referencing the scope context.\n            // Thanks to Andrew Dupont for this technique.\n\n            if (nodeType === 1 && rdescend.test(selector)) {\n              // Capture the context ID, setting it first if necessary\n              if (nid = context.getAttribute(\"id\")) {\n                nid = nid.replace(rcssescape, fcssescape);\n              } else {\n                context.setAttribute(\"id\", nid = expando);\n              } // Prefix every selector in the list\n\n\n              groups = tokenize(selector);\n              i = groups.length;\n\n              while (i--) {\n                groups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\n              }\n\n              newSelector = groups.join(\",\"); // Expand context for sibling selectors\n\n              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n            }\n\n            try {\n              push.apply(results, newContext.querySelectorAll(newSelector));\n              return results;\n            } catch (qsaError) {\n              nonnativeSelectorCache(selector, true);\n            } finally {\n              if (nid === expando) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {function(string, object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var keys = [];\n\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n\n        return cache[key + \" \"] = value;\n      }\n\n      return cache;\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created element and returns a boolean result\n     */\n\n\n    function assert(fn) {\n      var el = document.createElement(\"fieldset\");\n\n      try {\n        return !!fn(el);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        } // release memory in IE\n\n\n        el = null;\n      }\n    }\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n\n\n    function addHandle(attrs, handler) {\n      var arr = attrs.split(\"|\"),\n          i = arr.length;\n\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    }\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for :enabled/:disabled\n     * @param {Boolean} disabled true for :disabled; false for :enabled\n     */\n\n\n    function createDisabledPseudo(disabled) {\n      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n      return function (elem) {\n        // Only certain elements can match :enabled or :disabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n        if (\"form\" in elem) {\n          // Check for inherited disabledness on relevant non-disabled elements:\n          // * listed form-associated elements in a disabled fieldset\n          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n          // * option elements in a disabled optgroup\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n          // All such elements have a \"form\" property.\n          if (elem.parentNode && elem.disabled === false) {\n            // Option elements defer to a parent optgroup if present\n            if (\"label\" in elem) {\n              if (\"label\" in elem.parentNode) {\n                return elem.parentNode.disabled === disabled;\n              } else {\n                return elem.disabled === disabled;\n              }\n            } // Support: IE 6 - 11\n            // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n            /* jshint -W018 */\n            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n          }\n\n          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n          // even exist on them, let alone have a boolean value.\n        } else if (\"label\" in elem) {\n          return elem.disabled === disabled;\n        } // Remaining elements are neither :enabled nor :disabled\n\n\n        return false;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n\n\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    } // Expose support vars for convenience\n\n\n    support = Sizzle.support = {};\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n\n    isXML = Sizzle.isXML = function (elem) {\n      var namespace = elem.namespaceURI,\n          docElem = (elem.ownerDocument || elem).documentElement; // Support: IE <=8\n      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n      // https://bugs.jquery.com/ticket/4833\n\n      return !rhtml.test(namespace || docElem && docElem.nodeName || \"HTML\");\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n          subWindow,\n          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n\n      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Update global variables\n\n\n      document = doc;\n      docElem = document.documentElement;\n      documentIsHTML = !isXML(document); // Support: IE 9-11, Edge\n      // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\n      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n        // Support: IE 11, Edge\n        if (subWindow.addEventListener) {\n          subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n        } else if (subWindow.attachEvent) {\n          subWindow.attachEvent(\"onunload\", unloadHandler);\n        }\n      }\n      /* Attributes\n      ---------------------------------------------------------------------- */\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n\n\n      support.attributes = assert(function (el) {\n        el.className = \"i\";\n        return !el.getAttribute(\"className\");\n      });\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n      // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.getElementsByTagName = assert(function (el) {\n        el.appendChild(document.createComment(\"\"));\n        return !el.getElementsByTagName(\"*\").length;\n      }); // Support: IE<9\n\n      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programmatically-set names,\n      // so use a roundabout getElementsByName test\n\n      support.getById = assert(function (el) {\n        docElem.appendChild(el).id = expando;\n        return !document.getElementsByName || !document.getElementsByName(expando).length;\n      }); // ID filter and find\n\n      if (support.getById) {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var elem = context.getElementById(id);\n            return elem ? [elem] : [];\n          }\n        };\n      } else {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        }; // Support: IE 6 - 7 only\n        // getElementById is not reliable as a find shortcut\n\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var node,\n                i,\n                elems,\n                elem = context.getElementById(id);\n\n            if (elem) {\n              // Verify the id attribute\n              node = elem.getAttributeNode(\"id\");\n\n              if (node && node.value === id) {\n                return [elem];\n              } // Fall back on getElementsByName\n\n\n              elems = context.getElementsByName(id);\n              i = 0;\n\n              while (elem = elems[i++]) {\n                node = elem.getAttributeNode(\"id\");\n\n                if (node && node.value === id) {\n                  return [elem];\n                }\n              }\n            }\n\n            return [];\n          }\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n        results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Class\n\n      Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n        if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n      // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See https://bugs.jquery.com/ticket/13378\n\n      rbuggyQSA = [];\n\n      if (support.qsa = rnative.test(document.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (el) {\n          // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // https://bugs.jquery.com/ticket/12359\n          docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n          if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n\n\n          if (!el.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n          if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n            rbuggyQSA.push(\"~=\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!el.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          } // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibling-combinator selector` fails\n\n\n          if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n            rbuggyQSA.push(\".#.+[+~]\");\n          }\n        });\n        assert(function (el) {\n          el.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"; // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n\n          var input = document.createElement(\"input\");\n          input.setAttribute(\"type\", \"hidden\");\n          el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n          // Enforce case-sensitivity of name attribute\n\n          if (el.querySelectorAll(\"[name=d]\").length) {\n            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (el.querySelectorAll(\":enabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Support: IE9-11+\n          // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n          docElem.appendChild(el).disabled = true;\n\n          if (el.querySelectorAll(\":disabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          el.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (el) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(el, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n      /* Contains\n      ---------------------------------------------------------------------- */\n\n      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n      // Purposefully self-exclusive\n      // As in, an element does not contain itself\n\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /* Sorting\n      ---------------------------------------------------------------------- */\n      // Document order sorting\n\n      sortOrder = hasCompare ? function (a, b) {\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        } // Sort on method existence if only one input has compareDocumentPosition\n\n\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n        if (compare) {\n          return compare;\n        } // Calculate position if both inputs belong to the same document\n\n\n        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n        1; // Disconnected nodes\n\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n          // Choose the first element that is related to our preferred document\n          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          }\n\n          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          } // Maintain original order\n\n\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Parentless nodes are either documents or disconnected\n\n        if (!aup || !bup) {\n          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n      };\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {\n          nonnativeSelectorCache(expr, true);\n        }\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      if ((context.ownerDocument || context) !== document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      var fn = Expr.attrHandle[name.toLowerCase()],\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\n      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n\n    Sizzle.escape = function (sel) {\n      return (sel + \"\").replace(rcssescape, fcssescape);\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    };\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          j = 0,\n          i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      } // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n\n\n      sortInput = null;\n      return results;\n    };\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      attrHandle: {},\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n          1 type (only|nth|...)\n          2 what (child|of-type)\n          3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          4 xn-component of xn+y argument ([+-]?\\d*n|)\n          5 sign of xn-component\n          6 x of xn-component\n          7 sign of y-component\n          8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n              unquoted = !match[6] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[3]) {\n            match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === \"*\" ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n          };\n        },\n        \"CHILD\": function CHILD(type, what, argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, context, xml) {\n            var cache,\n                uniqueCache,\n                outerCache,\n                node,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType,\n                diff = false;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                // ...in a gzip-friendly way\n                node = parent;\n                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    uniqueCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                }\n              } else {\n                // Use previously-cached element index if available\n                if (useCache) {\n                  // ...in a gzip-friendly way\n                  node = elem;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex;\n                } // xml :nth-child(...)\n                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                if (diff === false) {\n                  // Use the same loop as above to seek `elem` from the start\n                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                      // Cache the index of each encountered element\n                      if (useCache) {\n                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                        uniqueCache[type] = [dirruns, diff];\n                      }\n\n                      if (node === elem) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": createDisabledPseudo(false),\n        \"disabled\": createDisabledPseudo(true),\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument > length ? length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    };\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    } // Easy API for creating new setFilters\n\n\n    function setFilters() {}\n\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          skip = combinator.next,\n          key = skip || dir,\n          checkNonElements = base && key === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n\n        return false;\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n            uniqueCache,\n            outerCache,\n            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n\n              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n              if (skip && skip === elem.nodeName.toLowerCase()) {\n                elem = elem[dir] || elem;\n              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n\n        return false;\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n        checkContext = null;\n        return ret;\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({\n              value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n            })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n        var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n            // We must always have either seed elements or outermost context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n\n        if (outermost) {\n          outermostContext = context === document || context || outermost;\n        } // Add elements passing elementMatchers directly to results\n        // Support: IE<9, Safari\n        // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n        for (; i !== len && (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0;\n\n            if (!context && elem.ownerDocument !== document) {\n              setDocument(elem);\n              xml = !documentIsHTML;\n            }\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context || document, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n        // makes the latter nonnegative.\n\n\n        matchedCount += i; // Apply set filters to unmatched elements\n        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n        // no element matchers and no seed.\n        // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n        // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n        // numerically zero.\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, match\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n\n        i = match.length;\n\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n        cached.selector = selector;\n      }\n\n      return cached;\n    };\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n\n\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === \"function\" && selector,\n          match = !seed && tokenize(selector = compiled.selector || selector);\n      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n      // (the latter of which guarantees us context)\n\n      if (match.length === 1) {\n        // Reduce context if the leading compound selector is an ID\n        tokens = match[0] = match[0].slice(0);\n\n        if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n          context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n          if (!context) {\n            return results; // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n\n          selector = selector.slice(tokens.shift().value.length);\n        } // Fetch a seed set for right-to-left matching\n\n\n        i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n        while (i--) {\n          token = tokens[i]; // Abort if we hit a combinator\n\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n\n              break;\n            }\n          }\n        }\n      } // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    }; // One-time assignments\n    // Sort stability\n\n\n    support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n\n    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n\n    support.sortDetached = assert(function (el) {\n      // Should return 1, but returns 4 (following)\n      return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n    }); // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n    if (!assert(function (el) {\n      el.innerHTML = \"<a href='#'></a>\";\n      return el.firstChild.getAttribute(\"href\") === \"#\";\n    })) {\n      addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n        }\n      });\n    } // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n\n\n    if (!support.attributes || !assert(function (el) {\n      el.innerHTML = \"<input/>\";\n      el.firstChild.setAttribute(\"value\", \"\");\n      return el.firstChild.getAttribute(\"value\") === \"\";\n    })) {\n      addHandle(\"value\", function (elem, name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n          return elem.defaultValue;\n        }\n      });\n    } // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n    if (!assert(function (el) {\n      return el.getAttribute(\"disabled\") == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n\n    return Sizzle;\n  }(window);\n\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors; // Deprecated\n\n  jQuery.expr[\":\"] = jQuery.expr.pseudos;\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n  jQuery.escapeSelector = Sizzle.escape;\n\n  var dir = function dir(elem, _dir, until) {\n    var matched = [],\n        truncate = until !== undefined;\n\n    while ((elem = elem[_dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break;\n        }\n\n        matched.push(elem);\n      }\n    }\n\n    return matched;\n  };\n\n  var _siblings = function siblings(n, elem) {\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  };\n\n  var rneedsContext = jQuery.expr.match.needsContext;\n\n  function nodeName(elem, name) {\n    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n  }\n\n  ;\n  var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i; // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, not) {\n    if (isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    } // Single element\n\n\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    } // Arraylike of elements (jQuery, arguments, Array)\n\n\n    if (typeof qualifier !== \"string\") {\n      return jQuery.grep(elements, function (elem) {\n        return indexOf.call(qualifier, elem) > -1 !== not;\n      });\n    } // Filtered directly for both simple and complex selectors\n\n\n    return jQuery.filter(qualifier, elements, not);\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n\n    if (not) {\n      expr = \":not(\" + expr + \")\";\n    }\n\n    if (elems.length === 1 && elem.nodeType === 1) {\n      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n    }\n\n    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          ret,\n          len = this.length,\n          self = this;\n\n      if (typeof selector !== \"string\") {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      ret = this.pushStack([]);\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      }\n\n      return len > 1 ? jQuery.uniqueSort(ret) : ret;\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function is(selector) {\n      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  }); // Initialize a jQuery object\n  // A central reference to the root jQuery(document)\n\n  var rootjQuery,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  // Shortcut simple #id case for speed\n  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n      init = jQuery.fn.init = function (selector, context, root) {\n    var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n    if (!selector) {\n      return this;\n    } // Method init() accepts an alternate rootjQuery\n    // so migrate can support jQuery.sub (gh-2101)\n\n\n    root = root || rootjQuery; // Handle HTML strings\n\n    if (typeof selector === \"string\") {\n      if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n        // Assume that strings that start and end with <> are HTML and skip the regex check\n        match = [null, selector, null];\n      } else {\n        match = rquickExpr.exec(selector);\n      } // Match html or make sure no context is specified for #id\n\n\n      if (match && (match[1] || !context)) {\n        // HANDLE: $(html) -> $(array)\n        if (match[1]) {\n          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat\n          // Intentionally let the error be thrown if parseHTML is not present\n\n          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n            for (match in context) {\n              // Properties of context are called as methods if possible\n              if (isFunction(this[match])) {\n                this[match](context[match]); // ...and otherwise set as attributes\n              } else {\n                this.attr(match, context[match]);\n              }\n            }\n          }\n\n          return this; // HANDLE: $(#id)\n        } else {\n          elem = document.getElementById(match[2]);\n\n          if (elem) {\n            // Inject the element directly into the jQuery object\n            this[0] = elem;\n            this.length = 1;\n          }\n\n          return this;\n        } // HANDLE: $(expr, $(...))\n\n      } else if (!context || context.jquery) {\n        return (context || root).find(selector); // HANDLE: $(expr, context)\n        // (which is just equivalent to: $(context).find(expr)\n      } else {\n        return this.constructor(context).find(selector);\n      } // HANDLE: $(DOMElement)\n\n    } else if (selector.nodeType) {\n      this[0] = selector;\n      this.length = 1;\n      return this; // HANDLE: $(function)\n      // Shortcut for document ready\n    } else if (isFunction(selector)) {\n      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present\n      selector(jQuery);\n    }\n\n    return jQuery.makeArray(selector, this);\n  }; // Give the init function the jQuery prototype for later instantiation\n\n\n  init.prototype = jQuery.fn; // Initialize central reference\n\n  rootjQuery = jQuery(document);\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      // Methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.fn.extend({\n    has: function has(target) {\n      var targets = jQuery(target, this),\n          l = targets.length;\n      return this.filter(function () {\n        var i = 0;\n\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          matched = [],\n          targets = typeof selectors !== \"string\" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context\n\n      if (!rneedsContext.test(selectors)) {\n        for (; i < l; i++) {\n          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n            // Always skip document fragments\n            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle\n            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n              matched.push(cur);\n              break;\n            }\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n    },\n    // Determine the position of an element within the set\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // Index in selector\n\n\n      if (typeof elem === \"string\") {\n        return indexOf.call(jQuery(elem), this[0]);\n      } // Locate the position of the desired element\n\n\n      return indexOf.call(this, // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem);\n    },\n    add: function add(selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n\n  function sibling(cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, i, until) {\n      return dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, i, until) {\n      return dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, i, until) {\n      return dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return _siblings((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return _siblings(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      if (typeof elem.contentDocument !== \"undefined\") {\n        return elem.contentDocument;\n      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n      // Treat the template element as a regular one in browsers that\n      // don't support it.\n\n\n      if (nodeName(elem, \"template\")) {\n        elem = elem.content || elem;\n      }\n\n      return jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var matched = jQuery.map(this, fn, until);\n\n      if (name.slice(-5) !== \"Until\") {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        matched = jQuery.filter(selector, matched);\n      }\n\n      if (this.length > 1) {\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          jQuery.uniqueSort(matched);\n        } // Reverse order for parents* and prev-derivatives\n\n\n        if (rparentsprev.test(name)) {\n          matched.reverse();\n        }\n      }\n\n      return this.pushStack(matched);\n    };\n  });\n  var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g; // Convert String-formatted options into Object-formatted ones\n\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n  * Create a callback list using the following parameters:\n  *\n  *\toptions: an optional list of space-separated options that will change how\n  *\t\t\tthe callback list behaves or a more traditional option object\n  *\n  * By default a callback list will act like an event callback list and can be\n  * \"fired\" multiple times.\n  *\n  * Possible options:\n  *\n  *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n  *\n  *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n  *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n  *\t\t\t\t\tvalues (like a Deferred)\n  *\n  *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n  *\n  *\tstopOnFalse:\tinterrupt callings when a callback returns false\n  *\n  */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value for non-forgettable lists\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // Flag to prevent firing\n    _locked,\n        // Actual callback list\n    list = [],\n        // Queue of execution data for repeatable lists\n    queue = [],\n        // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n        // Fire callbacks\n    fire = function fire() {\n      // Enforce single-firing\n      _locked = _locked || options.once; // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n\n      _fired = firing = true;\n\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n\n        while (++firingIndex < list.length) {\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      } // Forget the data if we're done with it\n\n\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false; // Clean up if we're done firing for good\n\n      if (_locked) {\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = []; // Otherwise, this object is spent\n        } else {\n          list = \"\";\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && toType(arg) !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        if (list) {\n          list = [];\n        }\n\n        return this;\n      },\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function disable() {\n        _locked = queue = [];\n        list = memory = \"\";\n        return this;\n      },\n      disabled: function disabled() {\n        return !list;\n      },\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function lock() {\n        _locked = queue = [];\n\n        if (!memory && !firing) {\n          list = memory = \"\";\n        }\n\n        return this;\n      },\n      locked: function locked() {\n        return !!_locked;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        if (!_locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n\n          if (!firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  function Identity(v) {\n    return v;\n  }\n\n  function Thrower(ex) {\n    throw ex;\n  }\n\n  function adoptValue(value, resolve, reject, noValue) {\n    var method;\n\n    try {\n      // Check for promise aspect first to privilege synchronous behavior\n      if (value && isFunction(method = value.promise)) {\n        method.call(value).done(resolve).fail(reject); // Other thenables\n      } else if (value && isFunction(method = value.then)) {\n        method.call(value, resolve, reject); // Other non-thenables\n      } else {\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n        // * false: [ value ].slice( 0 ) => resolve( value )\n        // * true: [ value ].slice( 1 ) => resolve()\n        resolve.apply(undefined, [value].slice(noValue));\n      } // For Promises/A+, convert exceptions into rejections\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n      // Deferred#then to conditionally suppress rejection.\n\n    } catch (value) {\n      // Support: Android 4.0 only\n      // Strict mode functions invoked without .call/.apply get global-object context\n      reject.apply(undefined, [value]);\n    }\n  }\n\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [// action, add listener, callbacks,\n      // ... .then handlers, argument index, [final state]\n      [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"), jQuery.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]],\n          _state = \"pending\",\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        \"catch\": function _catch(fn) {\n          return _promise.then(null, fn);\n        },\n        // Keep pipe for back-compat\n        pipe: function pipe()\n        /* fnDone, fnFail, fnProgress */\n        {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (i, tuple) {\n              // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })\n              // deferred.done(function() { bind to newDefer or newDefer.resolve })\n              // deferred.fail(function() { bind to newDefer or newDefer.reject })\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && isFunction(returned.promise)) {\n                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                } else {\n                  newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        then: function then(onFulfilled, onRejected, onProgress) {\n          var maxDepth = 0;\n\n          function resolve(depth, deferred, handler, special) {\n            return function () {\n              var that = this,\n                  args = arguments,\n                  mightThrow = function mightThrow() {\n                var returned, then; // Support: Promises/A+ section 2.3.3.3.3\n                // https://promisesaplus.com/#point-59\n                // Ignore double-resolution attempts\n\n                if (depth < maxDepth) {\n                  return;\n                }\n\n                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1\n                // https://promisesaplus.com/#point-48\n\n                if (returned === deferred.promise()) {\n                  throw new TypeError(\"Thenable self-resolution\");\n                } // Support: Promises/A+ sections 2.3.3.1, 3.5\n                // https://promisesaplus.com/#point-54\n                // https://promisesaplus.com/#point-75\n                // Retrieve `then` only once\n\n\n                then = returned && ( // Support: Promises/A+ section 2.3.4\n                // https://promisesaplus.com/#point-64\n                // Only check objects and functions for thenability\n                _typeof(returned) === \"object\" || typeof returned === \"function\") && returned.then; // Handle a returned thenable\n\n                if (isFunction(then)) {\n                  // Special processors (notify) just wait for resolution\n                  if (special) {\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress\n                  } else {\n                    // ...and disregard older resolution values\n                    maxDepth++;\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                  } // Handle all other returned values\n\n                } else {\n                  // Only substitute handlers pass on context\n                  // and multiple values (non-spec behavior)\n                  if (handler !== Identity) {\n                    that = undefined;\n                    args = [returned];\n                  } // Process the value(s)\n                  // Default process is resolve\n\n\n                  (special || deferred.resolveWith)(that, args);\n                }\n              },\n                  // Only normal processors (resolve) catch and reject exceptions\n              process = special ? mightThrow : function () {\n                try {\n                  mightThrow();\n                } catch (e) {\n                  if (jQuery.Deferred.exceptionHook) {\n                    jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                  } // Support: Promises/A+ section 2.3.3.3.4.1\n                  // https://promisesaplus.com/#point-61\n                  // Ignore post-resolution exceptions\n\n\n                  if (depth + 1 >= maxDepth) {\n                    // Only substitute handlers pass on context\n                    // and multiple values (non-spec behavior)\n                    if (handler !== Thrower) {\n                      that = undefined;\n                      args = [e];\n                    }\n\n                    deferred.rejectWith(that, args);\n                  }\n                }\n              }; // Support: Promises/A+ section 2.3.3.3.1\n              // https://promisesaplus.com/#point-57\n              // Re-resolve promises immediately to dodge false rejection from\n              // subsequent errors\n\n\n              if (depth) {\n                process();\n              } else {\n                // Call an optional hook to record the stack, in case of exception\n                // since it's otherwise lost when execution goes async\n                if (jQuery.Deferred.getStackHook) {\n                  process.stackTrace = jQuery.Deferred.getStackHook();\n                }\n\n                window.setTimeout(process);\n              }\n            };\n          }\n\n          return jQuery.Deferred(function (newDefer) {\n            // progress_handlers.add( ... )\n            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )\n\n            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )\n\n            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {}; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[5]; // promise.progress = list.add\n        // promise.done = list.add\n        // promise.fail = list.add\n\n        _promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = \"resolved\" (i.e., fulfilled)\n            // state = \"rejected\"\n            _state = stateString;\n          }, // rejected_callbacks.disable\n          // fulfilled_callbacks.disable\n          tuples[3 - i][2].disable, // rejected_handlers.disable\n          // fulfilled_handlers.disable\n          tuples[3 - i][3].disable, // progress_callbacks.lock\n          tuples[0][2].lock, // progress_handlers.lock\n          tuples[0][3].lock);\n        } // progress_handlers.fire\n        // fulfilled_handlers.fire\n        // rejected_handlers.fire\n\n\n        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n          return this;\n        }; // deferred.notifyWith = list.fireWith\n        // deferred.resolveWith = list.fireWith\n        // deferred.rejectWith = list.fireWith\n\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      _promise.promise(deferred); // Call given func if any\n\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(singleValue) {\n      var // count of uncompleted subordinates\n      remaining = arguments.length,\n          // count of unprocessed arguments\n      i = remaining,\n          // subordinate fulfillment data\n      resolveContexts = Array(i),\n          resolveValues = _slice.call(arguments),\n          // the master Deferred\n      master = jQuery.Deferred(),\n          // subordinate callback factory\n      updateFunc = function updateFunc(i) {\n        return function (value) {\n          resolveContexts[i] = this;\n          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\n          if (! --remaining) {\n            master.resolveWith(resolveContexts, resolveValues);\n          }\n        };\n      }; // Single- and empty arguments are adopted like Promise.resolve\n\n\n      if (remaining <= 1) {\n        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)\n\n        if (master.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n          return master.then();\n        }\n      } // Multiple arguments are aggregated like Promise.all array elements\n\n\n      while (i--) {\n        adoptValue(resolveValues[i], updateFunc(i), master.reject);\n      }\n\n      return master.promise();\n    }\n  }); // These usually indicate a programmer mistake during development,\n  // warn about them ASAP rather than swallowing them by default.\n\n  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n  jQuery.Deferred.exceptionHook = function (error, stack) {\n    // Support: IE 8 - 9 only\n    // Console exists when dev tools are open, which can happen at any time\n    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n      window.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\n    }\n  };\n\n  jQuery.readyException = function (error) {\n    window.setTimeout(function () {\n      throw error;\n    });\n  }; // The deferred used on DOM ready\n\n\n  var readyList = jQuery.Deferred();\n\n  jQuery.fn.ready = function (fn) {\n    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup\n    // happens at the time of error handling instead of callback\n    // registration.\n    [\"catch\"](function (error) {\n      jQuery.readyException(error);\n    });\n    return this;\n  };\n\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]);\n    }\n  });\n  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method\n\n  function completed() {\n    document.removeEventListener(\"DOMContentLoaded\", completed);\n    window.removeEventListener(\"load\", completed);\n    jQuery.ready();\n  } // Catch cases where $(document).ready() is called\n  // after the browser event has already occurred.\n  // Support: IE <=9 - 10 only\n  // Older IE sometimes signals \"interactive\" too soon\n\n\n  if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\n    window.setTimeout(jQuery.ready);\n  } else {\n    // Use the handy event callback\n    document.addEventListener(\"DOMContentLoaded\", completed); // A fallback to window.onload, that will always work\n\n    window.addEventListener(\"load\", completed);\n  } // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n\n\n  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n        len = elems.length,\n        bulk = key == null; // Sets many values\n\n    if (toType(key) === \"object\") {\n      chainable = true;\n\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw);\n      } // Sets one value\n\n    } else if (value !== undefined) {\n      chainable = true;\n\n      if (!isFunction(value)) {\n        raw = true;\n      }\n\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null; // ...except when executing function values\n        } else {\n          bulk = fn;\n\n          fn = function fn(elem, key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n\n    if (chainable) {\n      return elems;\n    } // Gets\n\n\n    if (bulk) {\n      return fn.call(elems);\n    }\n\n    return len ? fn(elems[0], key) : emptyGet;\n  }; // Matches dashed string for camelizing\n\n\n  var rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()\n\n  function fcamelCase(all, letter) {\n    return letter.toUpperCase();\n  } // Convert dashed to camelCase; used by the css and data modules\n  // Support: IE <=9 - 11, Edge 12 - 15\n  // Microsoft forgot to hump their vendor prefix (#9572)\n\n\n  function camelCase(string) {\n    return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n  }\n\n  var acceptData = function acceptData(owner) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n  };\n\n  function Data() {\n    this.expando = jQuery.expando + Data.uid++;\n  }\n\n  Data.uid = 1;\n  Data.prototype = {\n    cache: function cache(owner) {\n      // Check if the owner object already has a cache\n      var value = owner[this.expando]; // If not, create one\n\n      if (!value) {\n        value = {}; // We can accept data for non-element nodes in modern browsers,\n        // but we should not, see #8335.\n        // Always return an empty object.\n\n        if (acceptData(owner)) {\n          // If it is a node unlikely to be stringify-ed or looped over\n          // use plain assignment\n          if (owner.nodeType) {\n            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property\n            // configurable must be true to allow the property to be\n            // deleted when data is removed\n          } else {\n            Object.defineProperty(owner, this.expando, {\n              value: value,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function set(owner, data, value) {\n      var prop,\n          cache = this.cache(owner); // Handle: [ owner, key, value ] args\n      // Always use camelCase key (gh-2257)\n\n      if (typeof data === \"string\") {\n        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args\n      } else {\n        // Copy the properties one-by-one to the cache object\n        for (prop in data) {\n          cache[camelCase(prop)] = data[prop];\n        }\n      }\n\n      return cache;\n    },\n    get: function get(owner, key) {\n      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)\n      owner[this.expando] && owner[this.expando][camelCase(key)];\n    },\n    access: function access(owner, key, value) {\n      // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n      if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n        return this.get(owner, key);\n      } // When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n\n\n      this.set(owner, key, value); // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n\n      return value !== undefined ? value : key;\n    },\n    remove: function remove(owner, key) {\n      var i,\n          cache = owner[this.expando];\n\n      if (cache === undefined) {\n        return;\n      }\n\n      if (key !== undefined) {\n        // Support array or space separated string of keys\n        if (Array.isArray(key)) {\n          // If key is an array of keys...\n          // We always set camelCase keys, so remove that.\n          key = key.map(camelCase);\n        } else {\n          key = camelCase(key); // If a key with the spaces exists, use it.\n          // Otherwise, create an array by matching non-whitespace\n\n          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n        }\n\n        i = key.length;\n\n        while (i--) {\n          delete cache[key[i]];\n        }\n      } // Remove the expando if there's no more data\n\n\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\n        // Support: Chrome <=35 - 45\n        // Webkit & Blink performance suffers when deleting properties\n        // from DOM nodes, so set to undefined instead\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n        if (owner.nodeType) {\n          owner[this.expando] = undefined;\n        } else {\n          delete owner[this.expando];\n        }\n      }\n    },\n    hasData: function hasData(owner) {\n      var cache = owner[this.expando];\n      return cache !== undefined && !jQuery.isEmptyObject(cache);\n    }\n  };\n  var dataPriv = new Data();\n  var dataUser = new Data(); //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      rmultiDash = /[A-Z]/g;\n\n  function getData(data) {\n    if (data === \"true\") {\n      return true;\n    }\n\n    if (data === \"false\") {\n      return false;\n    }\n\n    if (data === \"null\") {\n      return null;\n    } // Only convert to a number if it doesn't change the string\n\n\n    if (data === +data + \"\") {\n      return +data;\n    }\n\n    if (rbrace.test(data)) {\n      return JSON.parse(data);\n    }\n\n    return data;\n  }\n\n  function dataAttr(elem, key, data) {\n    var name; // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n\n    if (data === undefined && elem.nodeType === 1) {\n      name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = getData(data);\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        dataUser.set(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  }\n\n  jQuery.extend({\n    hasData: function hasData(elem) {\n      return dataUser.hasData(elem) || dataPriv.hasData(elem);\n    },\n    data: function data(elem, name, _data) {\n      return dataUser.access(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      dataUser.remove(elem, name);\n    },\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to dataPriv methods, these can be deprecated.\n    _data: function _data(elem, name, data) {\n      return dataPriv.access(elem, name, data);\n    },\n    _removeData: function _removeData(elem, name) {\n      dataPriv.remove(elem, name);\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var i,\n          name,\n          data,\n          elem = this[0],\n          attrs = elem && elem.attributes; // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = dataUser.get(elem);\n\n          if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n            i = attrs.length;\n\n            while (i--) {\n              // Support: IE 11 only\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n\n                if (name.indexOf(\"data-\") === 0) {\n                  name = camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n\n            dataPriv.set(elem, \"hasDataAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          dataUser.set(this, key);\n        });\n      }\n\n      return access(this, function (value) {\n        var data; // The calling jQuery object (element matches) is not empty\n        // (and therefore has an element appears at this[ 0 ]) and the\n        // `value` parameter was not undefined. An empty jQuery object\n        // will result in `undefined` for elem = this[ 0 ] which will\n        // throw an exception if an attempt to read a data cache is made.\n\n        if (elem && value === undefined) {\n          // Attempt to get data from the cache\n          // The key will always be camelCased in Data\n          data = dataUser.get(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // Attempt to \"discover\" the data in\n          // HTML5 custom data-* attrs\n\n\n          data = dataAttr(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // We tried really hard, but the data doesn't exist.\n\n\n          return;\n        } // Set the data...\n\n\n        this.each(function () {\n          // We always store the camelCased key\n          dataUser.set(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        dataUser.remove(this, key);\n      });\n    }\n  });\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || Array.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // Clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          dataPriv.remove(elem, [type + \"queue\", key]);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n  var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n  var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n  var documentElement = document.documentElement;\n\n  var isAttached = function isAttached(elem) {\n    return jQuery.contains(elem.ownerDocument, elem);\n  },\n      composed = {\n    composed: true\n  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n  // Check attachment across shadow DOM boundaries when possible (gh-3504)\n  // Support: iOS 10.0-10.2 only\n  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n  // leading to errors. We need to check for `getRootNode`.\n\n\n  if (documentElement.getRootNode) {\n    isAttached = function isAttached(elem) {\n      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;\n    };\n  }\n\n  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {\n    // isHiddenWithinTree might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem; // Inline style trumps all\n\n    return elem.style.display === \"none\" || elem.style.display === \"\" && // Otherwise, check computed style\n    // Support: Firefox <=43 - 45\n    // Disconnected elements can have computed display: none, so first confirm that elem is\n    // in the document.\n    isAttached(elem) && jQuery.css(elem, \"display\") === \"none\";\n  };\n\n  var swap = function swap(elem, options, callback, args) {\n    var ret,\n        name,\n        old = {}; // Remember the old values, and insert the new ones\n\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n\n    ret = callback.apply(elem, args || []); // Revert the old values\n\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n\n    return ret;\n  };\n\n  function adjustCSS(elem, prop, valueParts, tween) {\n    var adjusted,\n        scale,\n        maxIterations = 20,\n        currentValue = tween ? function () {\n      return tween.cur();\n    } : function () {\n      return jQuery.css(elem, prop, \"\");\n    },\n        initial = currentValue(),\n        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n        // Starting value computation is required for potential unit mismatches\n    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n    if (initialInUnit && initialInUnit[3] !== unit) {\n      // Support: Firefox <=54\n      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n      initial = initial / 2; // Trust units reported by jQuery.css\n\n      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point\n\n      initialInUnit = +initial || 1;\n\n      while (maxIterations--) {\n        // Evaluate and update our best guess (doubling guesses that zero out).\n        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n        jQuery.style(elem, prop, initialInUnit + unit);\n\n        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n          maxIterations = 0;\n        }\n\n        initialInUnit = initialInUnit / scale;\n      }\n\n      initialInUnit = initialInUnit * 2;\n      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on\n\n      valueParts = valueParts || [];\n    }\n\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified\n\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n\n      if (tween) {\n        tween.unit = unit;\n        tween.start = initialInUnit;\n        tween.end = adjusted;\n      }\n    }\n\n    return adjusted;\n  }\n\n  var defaultDisplayMap = {};\n\n  function getDefaultDisplay(elem) {\n    var temp,\n        doc = elem.ownerDocument,\n        nodeName = elem.nodeName,\n        display = defaultDisplayMap[nodeName];\n\n    if (display) {\n      return display;\n    }\n\n    temp = doc.body.appendChild(doc.createElement(nodeName));\n    display = jQuery.css(temp, \"display\");\n    temp.parentNode.removeChild(temp);\n\n    if (display === \"none\") {\n      display = \"block\";\n    }\n\n    defaultDisplayMap[nodeName] = display;\n    return display;\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        values = [],\n        index = 0,\n        length = elements.length; // Determine new display value for elements that need to change\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      display = elem.style.display;\n\n      if (show) {\n        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n        // check is required in this first loop unless we have a nonempty display value (either\n        // inline or about-to-be-restored)\n        if (display === \"none\") {\n          values[index] = dataPriv.get(elem, \"display\") || null;\n\n          if (!values[index]) {\n            elem.style.display = \"\";\n          }\n        }\n\n        if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n          values[index] = getDefaultDisplay(elem);\n        }\n      } else {\n        if (display !== \"none\") {\n          values[index] = \"none\"; // Remember what we're overwriting\n\n          dataPriv.set(elem, \"display\", display);\n        }\n      }\n    } // Set the display of the elements in a second loop to avoid constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      if (values[index] != null) {\n        elements[index].style.display = values[index];\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.fn.extend({\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      if (typeof state === \"boolean\") {\n        return state ? this.show() : this.hide();\n      }\n\n      return this.each(function () {\n        if (isHiddenWithinTree(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n  var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n  var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i; // We have to close these tags to support XHTML (#13200)\n\n  var wrapMap = {\n    // Support: IE <=9 only\n    option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n    // XHTML parsers do not magically insert elements in the\n    // same way that tag soup parsers do. So we cannot shorten\n    // this by omitting <tbody> or other required elements.\n    thead: [1, \"<table>\", \"</table>\"],\n    col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    _default: [0, \"\", \"\"]\n  }; // Support: IE <=9 only\n\n  wrapMap.optgroup = wrapMap.option;\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td;\n\n  function getAll(context, tag) {\n    // Support: IE <=9 - 11 only\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n    var ret;\n\n    if (typeof context.getElementsByTagName !== \"undefined\") {\n      ret = context.getElementsByTagName(tag || \"*\");\n    } else if (typeof context.querySelectorAll !== \"undefined\") {\n      ret = context.querySelectorAll(tag || \"*\");\n    } else {\n      ret = [];\n    }\n\n    if (tag === undefined || tag && nodeName(context, tag)) {\n      return jQuery.merge([context], ret);\n    }\n\n    return ret;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n    }\n  }\n\n  var rhtml = /<|&#?\\w+;/;\n\n  function buildFragment(elems, context, scripts, selection, ignored) {\n    var elem,\n        tmp,\n        tag,\n        wrap,\n        attached,\n        j,\n        fragment = context.createDocumentFragment(),\n        nodes = [],\n        i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      elem = elems[i];\n\n      if (elem || elem === 0) {\n        // Add nodes directly\n        if (toType(elem) === \"object\") {\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n        } else {\n          tmp = tmp || fragment.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n          tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n          wrap = wrapMap[tag] || wrapMap._default;\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content\n\n          j = wrap[0];\n\n          while (j--) {\n            tmp = tmp.lastChild;\n          } // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n\n\n          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container\n\n          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)\n\n          tmp.textContent = \"\";\n        }\n      }\n    } // Remove wrapper from fragment\n\n\n    fragment.textContent = \"\";\n    i = 0;\n\n    while (elem = nodes[i++]) {\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem);\n        }\n\n        continue;\n      }\n\n      attached = isAttached(elem); // Append to fragment\n\n      tmp = getAll(fragment.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n      if (attached) {\n        setGlobalEval(tmp);\n      } // Capture executables\n\n\n      if (scripts) {\n        j = 0;\n\n        while (elem = tmp[j++]) {\n          if (rscriptType.test(elem.type || \"\")) {\n            scripts.push(elem);\n          }\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  (function () {\n    var fragment = document.createDocumentFragment(),\n        div = fragment.appendChild(document.createElement(\"div\")),\n        input = document.createElement(\"input\"); // Support: Android 4.0 - 4.3 only\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n\n    input.setAttribute(\"type\", \"radio\");\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"name\", \"t\");\n    div.appendChild(input); // Support: Android <=4.1 only\n    // Older WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n  })();\n\n  var rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  } // Support: IE <=9 - 11+\n  // focus() and blur() are asynchronous, except when they are no-op.\n  // So expect focus to be synchronous when the element is already active,\n  // and blur to be synchronous when the element is not already active.\n  // (focus and blur are always synchronous in other supported browsers,\n  // this just defines when we can count on it).\n\n\n  function expectSync(elem, type) {\n    return elem === safeActiveElement() === (type === \"focus\");\n  } // Support: IE <=9 only\n  // Accessing document.activeElement can throw unexpectedly\n  // https://bugs.jquery.com/ticket/13393\n\n\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n\n  function _on(elem, types, selector, data, fn, one) {\n    var origFn, type; // Types can be a map of types/handlers\n\n    if (_typeof(types) === \"object\") {\n      // ( types-Object, selector, data )\n      if (typeof selector !== \"string\") {\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n\n      for (type in types) {\n        _on(elem, type, selector, data, types[type], one);\n      }\n\n      return elem;\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === \"string\") {\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n\n    if (fn === false) {\n      fn = returnFalse;\n    } else if (!fn) {\n      return elem;\n    }\n\n    if (one === 1) {\n      origFn = fn;\n\n      fn = function fn(event) {\n        // Can use an empty set, since event contains the info\n        jQuery().off(event);\n        return origFn.apply(this, arguments);\n      }; // Use same guid so caller can remove using origFn\n\n\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n    }\n\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector);\n    });\n  }\n  /*\n  * Helper functions for managing events -- not part of the public interface.\n  * Props to Dean Edwards' addEvent library for many of the ideas.\n  */\n\n\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var handleObjIn,\n          eventHandle,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)\n\n      if (!elemData) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Ensure that invalid selectors throw exceptions at attach time\n      // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\n\n      if (selector) {\n        jQuery.find.matchesSelector(documentElement, selector);\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = {};\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n      } // Handle multiple events separated by a space\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // There *must* be a type, no attaching namespace-only handlers\n\n        if (!type) {\n          continue;\n        } // If event changes its type, use the special event handlers for the changed type\n\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      }\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n          origCount,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove data and the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        dataPriv.remove(elem, \"handle events\");\n      }\n    },\n    dispatch: function dispatch(nativeEvent) {\n      // Make a writable jQuery.Event from the native event object\n      var event = jQuery.event.fix(nativeEvent);\n      var i,\n          j,\n          ret,\n          matched,\n          handleObj,\n          handlerQueue,\n          args = new Array(arguments.length),\n          handlers = (dataPriv.get(this, \"events\") || {})[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n      args[0] = event;\n\n      for (i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // If the event is namespaced, then each handler is only invoked if it is\n          // specially universal or its namespaces are a superset of the event's.\n          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var i,\n          handleObj,\n          sel,\n          matchedHandlers,\n          matchedSelectors,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target; // Find delegate handlers\n\n      if (delegateCount && // Support: IE <=9\n      // Black-hole SVG <use> instance trees (trac-13180)\n      cur.nodeType && // Support: Firefox <=42\n      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n      // Support: IE 11 only\n      // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n      !(event.type === \"click\" && event.button >= 1)) {\n        for (; cur !== this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n            matchedHandlers = [];\n            matchedSelectors = {};\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matchedSelectors[sel] === undefined) {\n                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matchedSelectors[sel]) {\n                matchedHandlers.push(handleObj);\n              }\n            }\n\n            if (matchedHandlers.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matchedHandlers\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      cur = this;\n\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: cur,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    addProp: function addProp(name, hook) {\n      Object.defineProperty(jQuery.Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: isFunction(hook) ? function () {\n          if (this.originalEvent) {\n            return hook(this.originalEvent);\n          }\n        } : function () {\n          if (this.originalEvent) {\n            return this.originalEvent[name];\n          }\n        },\n        set: function set(value) {\n          Object.defineProperty(this, name, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        }\n      });\n    },\n    fix: function fix(originalEvent) {\n      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      click: {\n        // Utilize native event to ensure correct state for checkable inputs\n        setup: function setup(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Claim the first handler\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            // dataPriv.set( el, \"click\", ... )\n            leverageNative(el, \"click\", returnTrue);\n          } // Return false to allow normal processing in the caller\n\n\n          return false;\n        },\n        trigger: function trigger(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Force setup before triggering a click\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            leverageNative(el, \"click\");\n          } // Return non-false to allow normal event-path propagation\n\n\n          return true;\n        },\n        // For cross-browser consistency, suppress native .click() on links\n        // Also prevent it if we're currently inside a leveraged native-event stack\n        _default: function _default(event) {\n          var target = event.target;\n          return rcheckableType.test(target.type) && target.click && nodeName(target, \"input\") && dataPriv.get(target, \"click\") || nodeName(target, \"a\");\n        }\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    }\n  }; // Ensure the presence of an event listener that handles manually-triggered\n  // synthetic events by interrupting progress until reinvoked in response to\n  // *native* events that it fires directly, ensuring that state changes have\n  // already occurred before other listeners are invoked.\n\n  function leverageNative(el, type, expectSync) {\n    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n    if (!expectSync) {\n      if (dataPriv.get(el, type) === undefined) {\n        jQuery.event.add(el, type, returnTrue);\n      }\n\n      return;\n    } // Register the controller as a special universal handler for all event namespaces\n\n\n    dataPriv.set(el, type, false);\n    jQuery.event.add(el, type, {\n      namespace: false,\n      handler: function handler(event) {\n        var notAsync,\n            result,\n            saved = dataPriv.get(this, type);\n\n        if (event.isTrigger & 1 && this[type]) {\n          // Interrupt processing of the outer synthetic .trigger()ed event\n          // Saved data should be false in such cases, but might be a leftover capture object\n          // from an async native handler (gh-4350)\n          if (!saved.length) {\n            // Store arguments for use when handling the inner native event\n            // There will always be at least one argument (an event object), so this array\n            // will not be confused with a leftover capture object.\n            saved = _slice.call(arguments);\n            dataPriv.set(this, type, saved); // Trigger the native event and capture its result\n            // Support: IE <=9 - 11+\n            // focus() and blur() are asynchronous\n\n            notAsync = expectSync(this, type);\n            this[type]();\n            result = dataPriv.get(this, type);\n\n            if (saved !== result || notAsync) {\n              dataPriv.set(this, type, false);\n            } else {\n              result = {};\n            }\n\n            if (saved !== result) {\n              // Cancel the outer synthetic event\n              event.stopImmediatePropagation();\n              event.preventDefault();\n              return result.value;\n            } // If this is an inner synthetic event for an event with a bubbling surrogate\n            // (focus or blur), assume that the surrogate already propagated from triggering the\n            // native event and prevent that from happening again here.\n            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n            // bubbling surrogate propagates *after* the non-bubbling base), but that seems\n            // less bad than duplication.\n\n          } else if ((jQuery.event.special[type] || {}).delegateType) {\n            event.stopPropagation();\n          } // If this is a native event triggered above, everything is now in order\n          // Fire an inner synthetic event with the original arguments\n\n        } else if (saved.length) {\n          // ...and capture the result\n          dataPriv.set(this, type, {\n            value: jQuery.event.trigger( // Support: IE <=9 - 11+\n            // Extend with the prototype to reset the above stopImmediatePropagation()\n            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)\n          }); // Abort handling of the native event\n\n          event.stopImmediatePropagation();\n        }\n      }\n    });\n  }\n\n  jQuery.removeEvent = function (elem, type, handle) {\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only\n      src.returnValue === false ? returnTrue : returnFalse; // Create target properties\n      // Support: Safari <=6 - 7 only\n      // Target should not be a text node (#504, #13143)\n\n      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n      this.currentTarget = src.currentTarget;\n      this.relatedTarget = src.relatedTarget; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    isSimulated: false,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var e = this.originalEvent;\n      this.isImmediatePropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopImmediatePropagation();\n      }\n\n      this.stopPropagation();\n    }\n  }; // Includes all common event props including KeyEvent and MouseEvent specific props\n\n  jQuery.each({\n    altKey: true,\n    bubbles: true,\n    cancelable: true,\n    changedTouches: true,\n    ctrlKey: true,\n    detail: true,\n    eventPhase: true,\n    metaKey: true,\n    pageX: true,\n    pageY: true,\n    shiftKey: true,\n    view: true,\n    \"char\": true,\n    code: true,\n    charCode: true,\n    key: true,\n    keyCode: true,\n    button: true,\n    buttons: true,\n    clientX: true,\n    clientY: true,\n    offsetX: true,\n    offsetY: true,\n    pointerId: true,\n    pointerType: true,\n    screenX: true,\n    screenY: true,\n    targetTouches: true,\n    toElement: true,\n    touches: true,\n    which: function which(event) {\n      var button = event.button; // Add which for key events\n\n      if (event.which == null && rkeyEvent.test(event.type)) {\n        return event.charCode != null ? event.charCode : event.keyCode;\n      } // Add which for click: 1 === left; 2 === middle; 3 === right\n\n\n      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\n        if (button & 1) {\n          return 1;\n        }\n\n        if (button & 2) {\n          return 3;\n        }\n\n        if (button & 4) {\n          return 2;\n        }\n\n        return 0;\n      }\n\n      return event.which;\n    }\n  }, jQuery.event.addProp);\n  jQuery.each({\n    focus: \"focusin\",\n    blur: \"focusout\"\n  }, function (type, delegateType) {\n    jQuery.event.special[type] = {\n      // Utilize native event if possible so blur/focus sequence is correct\n      setup: function setup() {\n        // Claim the first handler\n        // dataPriv.set( this, \"focus\", ... )\n        // dataPriv.set( this, \"blur\", ... )\n        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller\n\n        return false;\n      },\n      trigger: function trigger() {\n        // Force setup before trigger\n        leverageNative(this, type); // Return non-false to allow normal event-path propagation\n\n        return true;\n      },\n      delegateType: delegateType\n    };\n  }); // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  });\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn);\n    },\n    one: function one(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    }\n  });\n  var\n  /* eslint-disable max-len */\n  // See https://github.com/eslint/eslint/issues/3229\n  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n  /* eslint-enable */\n  // Support: IE <=10 - 11, Edge 12 - 13 only\n  // In IE/Edge using regex groups here causes severe slowdowns.\n  // See https://connect.microsoft.com/IE/feedback/details/1736512/\n  rnoInnerhtml = /<script|<style|<link/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g; // Prefer a tbody over its parent table for containing new rows\n\n  function manipulationTarget(elem, content) {\n    if (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n      return jQuery(elem).children(\"tbody\")[0] || elem;\n    }\n\n    return elem;\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    if ((elem.type || \"\").slice(0, 5) === \"true/\") {\n      elem.type = elem.type.slice(5);\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  }\n\n  function cloneCopyEvent(src, dest) {\n    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n    if (dest.nodeType !== 1) {\n      return;\n    } // 1. Copy private data: events, handlers, etc.\n\n\n    if (dataPriv.hasData(src)) {\n      pdataOld = dataPriv.access(src);\n      pdataCur = dataPriv.set(dest, pdataOld);\n      events = pdataOld.events;\n\n      if (events) {\n        delete pdataCur.handle;\n        pdataCur.events = {};\n\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i]);\n          }\n        }\n      }\n    } // 2. Copy user data\n\n\n    if (dataUser.hasData(src)) {\n      udataOld = dataUser.access(src);\n      udataCur = jQuery.extend({}, udataOld);\n      dataUser.set(dest, udataCur);\n    }\n  } // Fix IE bugs, see support tests\n\n\n  function fixInput(src, dest) {\n    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.\n\n    if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  function domManip(collection, args, callback, ignored) {\n    // Flatten any nested arrays\n    args = concat.apply([], args);\n    var fragment,\n        first,\n        scripts,\n        hasScripts,\n        node,\n        doc,\n        i = 0,\n        l = collection.length,\n        iNoClone = l - 1,\n        value = args[0],\n        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n    if (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n      return collection.each(function (index) {\n        var self = collection.eq(index);\n\n        if (valueIsFunction) {\n          args[0] = value.call(this, index, self.html());\n        }\n\n        domManip(self, args, callback, ignored);\n      });\n    }\n\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n      first = fragment.firstChild;\n\n      if (fragment.childNodes.length === 1) {\n        fragment = first;\n      } // Require either new content or an interest in ignored elements to invoke the callback\n\n\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n        hasScripts = scripts.length; // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n\n        for (; i < l; i++) {\n          node = fragment;\n\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n            if (hasScripts) {\n              // Support: Android <=4.0 only, PhantomJS 1 only\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, \"script\"));\n            }\n          }\n\n          callback.call(collection[i], node, i);\n        }\n\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i];\n\n            if (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n              if (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl && !node.noModule) {\n                  jQuery._evalUrl(node.src, {\n                    nonce: node.nonce || node.getAttribute(\"nonce\")\n                  });\n                }\n              } else {\n                DOMEval(node.textContent.replace(rcleanScript, \"\"), node, doc);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collection;\n  }\n\n  function _remove(elem, selector, keepData) {\n    var node,\n        nodes = selector ? jQuery.filter(selector, elem) : elem,\n        i = 0;\n\n    for (; (node = nodes[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node));\n      }\n\n      if (node.parentNode) {\n        if (keepData && isAttached(node)) {\n          setGlobalEval(getAll(node, \"script\"));\n        }\n\n        node.parentNode.removeChild(node);\n      }\n    }\n\n    return elem;\n  }\n\n  jQuery.extend({\n    htmlPrefilter: function htmlPrefilter(html) {\n      return html.replace(rxhtmlTag, \"<$1></$2>\");\n    },\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n          l,\n          srcElements,\n          destElements,\n          clone = elem.cloneNode(true),\n          inPage = isAttached(elem); // Fix IE cloning issues\n\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem);\n\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i]);\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      } // Return the cloned set\n\n\n      return clone;\n    },\n    cleanData: function cleanData(elems) {\n      var data,\n          elem,\n          type,\n          special = jQuery.event.special,\n          i = 0;\n\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (acceptData(elem)) {\n          if (data = elem[dataPriv.expando]) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            } // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n\n\n            elem[dataPriv.expando] = undefined;\n          }\n\n          if (elem[dataUser.expando]) {\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataUser.expando] = undefined;\n          }\n        }\n      }\n    }\n  });\n  jQuery.fn.extend({\n    detach: function detach(selector) {\n      return _remove(this, selector, true);\n    },\n    remove: function remove(selector) {\n      return _remove(this, selector);\n    },\n    text: function text(value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().each(function () {\n          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n            this.textContent = value;\n          }\n        });\n      }, null, value, arguments.length);\n    },\n    append: function append() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes\n\n          elem.textContent = \"\";\n        }\n      }\n\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined && elem.nodeType === 1) {\n          return elem.innerHTML;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = jQuery.htmlPrefilter(value);\n\n          try {\n            for (; i < l; i++) {\n              elem = this[i] || {}; // Remove element nodes and prevent memory leaks\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith() {\n      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content\n\n      return domManip(this, arguments, function (elem) {\n        var parent = this.parentNode;\n\n        if (jQuery.inArray(this, ignored) < 0) {\n          jQuery.cleanData(getAll(this));\n\n          if (parent) {\n            parent.replaceChild(elem, this);\n          }\n        } // Force callback invocation\n\n      }, ignored);\n    }\n  });\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1,\n          i = 0;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only\n        // .get() because push.apply(_, arraylike) throws on ancient WebKit\n\n        push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n  var getStyles = function getStyles(elem) {\n    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    var view = elem.ownerDocument.defaultView;\n\n    if (!view || !view.opener) {\n      view = window;\n    }\n\n    return view.getComputedStyle(elem);\n  };\n\n  var rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n\n  (function () {\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n    function computeStyleTests() {\n      // This is a singleton, we need to execute it only once\n      if (!div) {\n        return;\n      }\n\n      container.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n      div.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n      documentElement.appendChild(container).appendChild(div);\n      var divStyle = window.getComputedStyle(div);\n      pixelPositionVal = divStyle.top !== \"1%\"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\n      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n      // Some styles come back with percentage values, even though they shouldn't\n\n      div.style.right = \"60%\";\n      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only\n      // Detect misreporting of content dimensions for box-sizing:border-box elements\n\n      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only\n      // Detect overflow:scroll screwiness (gh-3699)\n      // Support: Chrome <=64\n      // Don't get tricked when zoom affects offsetWidth (gh-4029)\n\n      div.style.position = \"absolute\";\n      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\n      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and\n      // it will also be a sign that checks already performed\n\n      div = null;\n    }\n\n    function roundPixelMeasures(measure) {\n      return Math.round(parseFloat(measure));\n    }\n\n    var pixelPositionVal,\n        boxSizingReliableVal,\n        scrollboxSizeVal,\n        pixelBoxStylesVal,\n        reliableMarginLeftVal,\n        container = document.createElement(\"div\"),\n        div = document.createElement(\"div\"); // Finish early in limited (non-browser) environments\n\n    if (!div.style) {\n      return;\n    } // Support: IE <=9 - 11 only\n    // Style of cloned element affects source element cloned (#8908)\n\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n    jQuery.extend(support, {\n      boxSizingReliable: function boxSizingReliable() {\n        computeStyleTests();\n        return boxSizingReliableVal;\n      },\n      pixelBoxStyles: function pixelBoxStyles() {\n        computeStyleTests();\n        return pixelBoxStylesVal;\n      },\n      pixelPosition: function pixelPosition() {\n        computeStyleTests();\n        return pixelPositionVal;\n      },\n      reliableMarginLeft: function reliableMarginLeft() {\n        computeStyleTests();\n        return reliableMarginLeftVal;\n      },\n      scrollboxSize: function scrollboxSize() {\n        computeStyleTests();\n        return scrollboxSizeVal;\n      }\n    });\n  })();\n\n  function curCSS(elem, name, computed) {\n    var width,\n        minWidth,\n        maxWidth,\n        ret,\n        // Support: Firefox 51+\n    // Retrieving style before computed somehow\n    // fixes an issue with getting wrong values\n    // on detached elements\n    style = elem.style;\n    computed = computed || getStyles(elem); // getPropertyValue is needed for:\n    //   .css('filter') (IE 9 only, #12537)\n    //   .css('--customProperty) (#3144)\n\n    if (computed) {\n      ret = computed.getPropertyValue(name) || computed[name];\n\n      if (ret === \"\" && !isAttached(elem)) {\n        ret = jQuery.style(elem, name);\n      } // A tribute to the \"awesome hack by Dean Edwards\"\n      // Android Browser returns percentage for some values,\n      // but width seems to be reliably pixels.\n      // This is against the CSSOM draft spec:\n      // https://drafts.csswg.org/cssom/#resolved-values\n\n\n      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n        // Remember the original values\n        width = style.width;\n        minWidth = style.minWidth;\n        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n        style.minWidth = style.maxWidth = style.width = ret;\n        ret = computed.width; // Revert the changed values\n\n        style.width = width;\n        style.minWidth = minWidth;\n        style.maxWidth = maxWidth;\n      }\n    }\n\n    return ret !== undefined ? // Support: IE <=9 - 11 only\n    // IE returns zIndex value as an integer.\n    ret + \"\" : ret;\n  }\n\n  function addGetHookIf(conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function get() {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        } // Hook needed; redefine it so that the support test is not executed again.\n\n\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n\n  var cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"],\n      emptyStyle = document.createElement(\"div\").style,\n      vendorProps = {}; // Return a vendor-prefixed property or undefined\n\n  function vendorPropName(name) {\n    // Check for vendor prefixed names\n    var capName = name[0].toUpperCase() + name.slice(1),\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n\n\n  function finalPropName(name) {\n    var _final = jQuery.cssProps[name] || vendorProps[name];\n\n    if (_final) {\n      return _final;\n    }\n\n    if (name in emptyStyle) {\n      return name;\n    }\n\n    return vendorProps[name] = vendorPropName(name) || name;\n  }\n\n  var // Swappable if display is none or starts with table\n  // except \"table\", \"table-cell\", or \"table-caption\"\n  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rcustomProp = /^--/,\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: \"0\",\n    fontWeight: \"400\"\n  };\n\n  function setPositiveNumber(elem, value, subtract) {\n    // Any relative (+/-) values have already been\n    // normalized at this point\n    var matches = rcssNum.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n  }\n\n  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n    var i = dimension === \"width\" ? 1 : 0,\n        extra = 0,\n        delta = 0; // Adjustment may not be necessary\n\n    if (box === (isBorderBox ? \"border\" : \"content\")) {\n      return 0;\n    }\n\n    for (; i < 4; i += 2) {\n      // Both box models exclude margin\n      if (box === \"margin\") {\n        delta += jQuery.css(elem, box + cssExpand[i], true, styles);\n      } // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\n\n      if (!isBorderBox) {\n        // Add padding\n        delta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // For \"border\" or \"margin\", add border\n\n        if (box !== \"padding\") {\n          delta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles); // But still keep track of it otherwise\n        } else {\n          extra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        } // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n        // \"padding\" or \"margin\"\n\n      } else {\n        // For \"content\", subtract padding\n        if (box === \"content\") {\n          delta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // For \"content\" or \"padding\", subtract border\n\n\n        if (box !== \"margin\") {\n          delta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    } // Account for positive content-box scroll gutter when requested by providing computedVal\n\n\n    if (!isBorderBox && computedVal >= 0) {\n      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n      // Assuming integer scroll gutter, subtract the rest and round down\n      delta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n      // Use an explicit zero to avoid NaN (gh-3964)\n      )) || 0;\n    }\n\n    return delta;\n  }\n\n  function getWidthOrHeight(elem, dimension, extra) {\n    // Start with computed style\n    var styles = getStyles(elem),\n        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n    // Fake content-box until we know it's needed to know the true value.\n    boxSizingNeeded = !support.boxSizingReliable() || extra,\n        isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n        valueIsBorderBox = isBorderBox,\n        val = curCSS(elem, dimension, styles),\n        offsetProp = \"offset\" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54\n    // Return a confounding non-pixel value or feign ignorance, as appropriate.\n\n    if (rnumnonpx.test(val)) {\n      if (!extra) {\n        return val;\n      }\n\n      val = \"auto\";\n    } // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n    // This happens for inline elements with no explicit setting (gh-3571)\n    // Support: Android <=4.1 - 4.3 only\n    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n    // Support: IE 9-11 only\n    // Also use offsetWidth/offsetHeight for when box sizing is unreliable\n    // We use getClientRects() to check for hidden/disconnected.\n    // In those cases, the computed value can be trusted to be border-box\n\n\n    if ((!support.boxSizingReliable() && isBorderBox || val === \"auto\" || !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") && elem.getClientRects().length) {\n      isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.\n      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n      // retrieved value as a content box dimension.\n\n      valueIsBorderBox = offsetProp in elem;\n\n      if (valueIsBorderBox) {\n        val = elem[offsetProp];\n      }\n    } // Normalize \"\" and auto\n\n\n    val = parseFloat(val) || 0; // Adjust for the element's box model\n\n    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)\n    val) + \"px\";\n  }\n\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      \"animationIterationCount\": true,\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"flexGrow\": true,\n      \"flexShrink\": true,\n      \"fontWeight\": true,\n      \"gridArea\": true,\n      \"gridColumn\": true,\n      \"gridColumnEnd\": true,\n      \"gridColumnStart\": true,\n      \"gridRow\": true,\n      \"gridRowEnd\": true,\n      \"gridRowStart\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"order\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {},\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name),\n          style = elem.style; // Make sure that we're working with the right name. We don't\n      // want to query the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Gets hook for the prefixed version, then unprefixed version\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = _typeof(value); // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\n        if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that null and NaN values aren't set (#7116)\n\n\n        if (value == null || value !== value) {\n          return;\n        } // If a number was passed in, add the unit (except for certain CSS properties)\n        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n        // \"px\" to a few hardcoded values.\n\n\n        if (type === \"number\" && !isCustomProp) {\n          value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n        } // background-* props affect original clone's values\n\n\n        if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          if (isCustomProp) {\n            style.setProperty(name, value);\n          } else {\n            style[name] = value;\n          }\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var val,\n          num,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't\n      // want to modify the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Try prefixed name followed by the unprefixed name\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } // Convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Make numeric if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || isFinite(num) ? num || 0 : val;\n      }\n\n      return val;\n    }\n  });\n  jQuery.each([\"height\", \"width\"], function (i, dimension) {\n    jQuery.cssHooks[dimension] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, \"display\")) && ( // Support: Safari 8+\n          // Table columns in Safari have non-zero offsetWidth & zero\n          // getBoundingClientRect().width unless display is changed.\n          // Support: IE <=11 only\n          // Running getBoundingClientRect on a disconnected node\n          // in IE throws an error.\n          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, dimension, extra);\n          }) : getWidthOrHeight(elem, dimension, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var matches,\n            styles = getStyles(elem),\n            // Only read styles.position if the test has a chance to fail\n        // to avoid forcing a reflow.\n        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === \"absolute\",\n            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n        boxSizingNeeded = scrollboxSizeBuggy || extra,\n            isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and\n        // faking a content-box to get border and padding (gh-3699)\n\n        if (isBorderBox && scrollboxSizeBuggy) {\n          subtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n        } // Convert to pixels if value adjustment is needed\n\n\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n          elem.style[dimension] = value;\n          value = jQuery.css(elem, dimension);\n        }\n\n        return setPositiveNumber(elem, value, subtract);\n      }\n    };\n  });\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, {\n        marginLeft: 0\n      }, function () {\n        return elem.getBoundingClientRect().left;\n      })) + \"px\";\n    }\n  }); // These hooks are used by animate to expand properties\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n            // Assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (prefix !== \"margin\") {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n            len,\n            map = {},\n            i = 0;\n\n        if (Array.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    }\n  });\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || jQuery.easing._default;\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result; // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n\n        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n          return tween.elem[tween.prop];\n        } // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Support: IE <=9 only\n  // Panic based approach to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    },\n    _default: \"swing\"\n  };\n  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point\n\n  jQuery.fx.step = {};\n  var fxNow,\n      inProgress,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rrun = /queueHooks$/;\n\n  function schedule() {\n    if (inProgress) {\n      if (document.hidden === false && window.requestAnimationFrame) {\n        window.requestAnimationFrame(schedule);\n      } else {\n        window.setTimeout(schedule, jQuery.fx.interval);\n      }\n\n      jQuery.fx.tick();\n    }\n  } // Animations created synchronously will run synchronously\n\n\n  function createFxNow() {\n    window.setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = Date.now();\n  } // Generate parameters to create a standard animation\n\n\n  function genFx(type, includeWidth) {\n    var which,\n        i = 0,\n        attrs = {\n      height: type\n    }; // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  }\n\n  function createTween(value, prop, animation) {\n    var tween,\n        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]),\n        index = 0,\n        length = collection.length;\n\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n        // We're done with this property\n        return tween;\n      }\n    }\n  }\n\n  function defaultPrefilter(elem, props, opts) {\n    var prop,\n        value,\n        toggle,\n        hooks,\n        oldfire,\n        propTween,\n        restoreDisplay,\n        display,\n        isBox = \"width\" in props || \"height\" in props,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHiddenWithinTree(elem),\n        dataShow = dataPriv.get(elem, \"fxshow\"); // Queue-skipping animations hijack the fx hooks\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // Detect show/hide animations\n\n\n    for (prop in props) {\n      value = props[prop];\n\n      if (rfxtypes.test(value)) {\n        delete props[prop];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          // Pretend to be hidden if this is a \"show\" and\n          // there is still data from a stopped show/hide\n          if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n            hidden = true; // Ignore all other no-op show/hide data\n          } else {\n            continue;\n          }\n        }\n\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n      }\n    } // Bail out if this is a no-op like .hide().hide()\n\n\n    propTween = !jQuery.isEmptyObject(props);\n\n    if (!propTween && jQuery.isEmptyObject(orig)) {\n      return;\n    } // Restrict \"overflow\" and \"display\" styles during box animations\n\n\n    if (isBox && elem.nodeType === 1) {\n      // Support: IE <=9 - 11, Edge 12 - 15\n      // Record all 3 overflow attributes because IE does not infer the shorthand\n      // from identically-valued overflowX and overflowY and Edge just mirrors\n      // the overflowX value there.\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade\n\n      restoreDisplay = dataShow && dataShow.display;\n\n      if (restoreDisplay == null) {\n        restoreDisplay = dataPriv.get(elem, \"display\");\n      }\n\n      display = jQuery.css(elem, \"display\");\n\n      if (display === \"none\") {\n        if (restoreDisplay) {\n          display = restoreDisplay;\n        } else {\n          // Get nonempty value(s) by temporarily forcing visibility\n          showHide([elem], true);\n          restoreDisplay = elem.style.display || restoreDisplay;\n          display = jQuery.css(elem, \"display\");\n          showHide([elem]);\n        }\n      } // Animate inline elements as inline-block\n\n\n      if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n        if (jQuery.css(elem, \"float\") === \"none\") {\n          // Restore the original display value at the end of pure show/hide animations\n          if (!propTween) {\n            anim.done(function () {\n              style.display = restoreDisplay;\n            });\n\n            if (restoreDisplay == null) {\n              display = style.display;\n              restoreDisplay = display === \"none\" ? \"\" : display;\n            }\n          }\n\n          style.display = \"inline-block\";\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n      anim.always(function () {\n        style.overflow = opts.overflow[0];\n        style.overflowX = opts.overflow[1];\n        style.overflowY = opts.overflow[2];\n      });\n    } // Implement show/hide animations\n\n\n    propTween = false;\n\n    for (prop in orig) {\n      // General show/hide setup for this element animation\n      if (!propTween) {\n        if (dataShow) {\n          if (\"hidden\" in dataShow) {\n            hidden = dataShow.hidden;\n          }\n        } else {\n          dataShow = dataPriv.access(elem, \"fxshow\", {\n            display: restoreDisplay\n          });\n        } // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\n\n        if (toggle) {\n          dataShow.hidden = !hidden;\n        } // Show elements before animating them\n\n\n        if (hidden) {\n          showHide([elem], true);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        anim.done(function () {\n          /* eslint-enable no-loop-func */\n          // The final step of a \"hide\" animation is actually hiding the element\n          if (!hidden) {\n            showHide([elem]);\n          }\n\n          dataPriv.remove(elem, \"fxshow\");\n\n          for (prop in orig) {\n            jQuery.style(elem, prop, orig[prop]);\n          }\n        });\n      } // Per-property setup\n\n\n      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n      if (!(prop in dataShow)) {\n        dataShow[prop] = propTween.start;\n\n        if (hidden) {\n          propTween.end = propTween.start;\n          propTween.start = 0;\n        }\n      }\n    }\n  }\n\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (Array.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = Animation.prefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // Don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3 only\n      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield\n\n      if (percent < 1 && length) {\n        return remaining;\n      } // If this was an empty animation, synthesize a final progress notification\n\n\n      if (!length) {\n        deferred.notifyWith(elem, [animation, 1, 0]);\n      } // Resolve the animation and report its conclusion\n\n\n      deferred.resolveWith(elem, [animation]);\n      return false;\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {},\n        easing: jQuery.easing._default\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n            // If we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // Resolve when we played the last frame; otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.notifyWith(elem, [animation, 1, 0]);\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        if (isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n        }\n\n        return result;\n      }\n    }\n\n    jQuery.map(props, createTween, animation);\n\n    if (isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    } // Attach callbacks from options\n\n\n    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    }));\n    return animation;\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweeners: {\n      \"*\": [function (prop, value) {\n        var tween = this.createTween(prop, value);\n        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n        return tween;\n      }]\n    },\n    tweener: function tweener(props, callback) {\n      if (isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.match(rnothtmlwhite);\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n        Animation.tweeners[prop].unshift(callback);\n      }\n    },\n    prefilters: [defaultPrefilter],\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback);\n      } else {\n        Animation.prefilters.push(callback);\n      }\n    }\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !isFunction(easing) && easing\n    }; // Go to the end state if fx are off\n\n    if (jQuery.fx.off) {\n      opt.duration = 0;\n    } else {\n      if (typeof opt.duration !== \"number\") {\n        if (opt.duration in jQuery.fx.speeds) {\n          opt.duration = jQuery.fx.speeds[opt.duration];\n        } else {\n          opt.duration = jQuery.fx.speeds._default;\n        }\n      }\n    } // Normalize opt.queue - true/undefined/null -> \"fx\"\n\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // Show any hidden elements after setting opacity to 0\n      return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show() // Animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately\n\n        if (empty || dataPriv.get(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue && type !== false) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = dataPriv.get(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = dataPriv.get(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // Enable finishing flag on private data\n\n        data.finish = true; // Empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        } // Look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // Look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // Turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  });\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  }); // Generate shortcuts for custom animations\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n  jQuery.timers = [];\n\n  jQuery.fx.tick = function () {\n    var timer,\n        i = 0,\n        timers = jQuery.timers;\n    fxNow = Date.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n    jQuery.fx.start();\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (inProgress) {\n      return;\n    }\n\n    inProgress = true;\n    schedule();\n  };\n\n  jQuery.fx.stop = function () {\n    inProgress = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Based off of the plugin by Clint Helfers, with permission.\n  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || \"fx\";\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time);\n\n      hooks.stop = function () {\n        window.clearTimeout(timeout);\n      };\n    });\n  };\n\n  (function () {\n    var input = document.createElement(\"input\"),\n        select = document.createElement(\"select\"),\n        opt = select.appendChild(document.createElement(\"option\"));\n    input.type = \"checkbox\"; // Support: Android <=4.3 only\n    // Default value for a checkbox should be \"on\"\n\n    support.checkOn = input.value !== \"\"; // Support: IE <=11 only\n    // Must access selectedIndex to make default options select\n\n    support.optSelected = opt.selected; // Support: IE <=11 only\n    // An input loses its value after becoming a radio\n\n    input = document.createElement(\"input\");\n    input.value = \"t\";\n    input.type = \"radio\";\n    support.radioValue = input.value === \"t\";\n  })();\n\n  var boolHook,\n      attrHandle = jQuery.expr.attrHandle;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n  jQuery.extend({\n    attr: function attr(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (typeof elem.getAttribute === \"undefined\") {\n        return jQuery.prop(elem, name, value);\n      } // Attribute hooks are determined by the lowercase version\n      // Grab necessary hook if one is defined\n\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n          return;\n        }\n\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        elem.setAttribute(name, value + \"\");\n        return value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined\n\n      return ret == null ? undefined : ret;\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          i = 0,\n          // Attribute names can contain non-HTML whitespace characters\n      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n      attrNames = value && value.match(rnothtmlwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          elem.removeAttribute(name);\n        }\n      }\n    }\n  }); // Hooks for boolean attributes\n\n  boolHook = {\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else {\n        elem.setAttribute(name, name);\n      }\n\n      return name;\n    }\n  };\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret,\n          handle,\n          lowercaseName = name.toLowerCase();\n\n      if (!isXML) {\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[lowercaseName];\n        attrHandle[lowercaseName] = ret;\n        ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n        attrHandle[lowercaseName] = handle;\n      }\n\n      return ret;\n    };\n  });\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\n      rclickable = /^(?:a|area)$/i;\n  jQuery.fn.extend({\n    prop: function prop(name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name];\n      });\n    }\n  });\n  jQuery.extend({\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        return elem[name] = value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      return elem[name];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          // Support: IE <=9 - 11 only\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, \"tabindex\");\n\n          if (tabindex) {\n            return parseInt(tabindex, 10);\n          }\n\n          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n            return 0;\n          }\n\n          return -1;\n        }\n      }\n    },\n    propFix: {\n      \"for\": \"htmlFor\",\n      \"class\": \"className\"\n    }\n  }); // Support: IE <=11 only\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n  // eslint rule \"no-unused-expressions\" is disabled for this code\n  // since it considers such accessions noop\n\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function get(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex;\n        }\n\n        return null;\n      },\n      set: function set(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex;\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n      }\n    };\n  }\n\n  jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  }); // Strip and collapse whitespace according to HTML spec\n  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\n  function stripAndCollapse(value) {\n    var tokens = value.match(rnothtmlwhite) || [];\n    return tokens.join(\" \");\n  }\n\n  function getClass(elem) {\n    return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n  }\n\n  function classesToArray(value) {\n    if (Array.isArray(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return value.match(rnothtmlwhite) || [];\n    }\n\n    return [];\n  }\n\n  jQuery.fn.extend({\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      if (!arguments.length) {\n        return this.attr(\"class\", \"\");\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value),\n          isValidValue = type === \"string\" || Array.isArray(value);\n\n      if (typeof stateVal === \"boolean\" && isValidValue) {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n\n      if (isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        var className, i, self, classNames;\n\n        if (isValidValue) {\n          // Toggle individual class names\n          i = 0;\n          self = jQuery(this);\n          classNames = classesToArray(value);\n\n          while (className = classNames[i++]) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          } // Toggle whole class name\n\n        } else if (value === undefined || type === \"boolean\") {\n          className = getClass(this);\n\n          if (className) {\n            // Store className if set\n            dataPriv.set(this, \"__className__\", className);\n          } // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          if (this.setAttribute) {\n            this.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n          }\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className,\n          elem,\n          i = 0;\n      className = \" \" + selector + \" \";\n\n      while (elem = this[i++]) {\n        if (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  var rreturn = /\\r/g;\n  jQuery.fn.extend({\n    val: function val(value) {\n      var hooks,\n          ret,\n          valueIsFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value; // Handle most common string cases\n\n          if (typeof ret === \"string\") {\n            return ret.replace(rreturn, \"\");\n          } // Handle cases where value is null/undef or number\n\n\n          return ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      valueIsFunction = isFunction(value);\n      return this.each(function (i) {\n        var val;\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (valueIsFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (Array.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          var val = jQuery.find.attr(elem, \"value\");\n          return val != null ? val : // Support: IE <=10 - 11 only\n          // option.text throws exceptions (#14686, #14858)\n          // Strip and collapse whitespace\n          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n          stripAndCollapse(jQuery.text(elem));\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              i,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\",\n              values = one ? null : [],\n              max = one ? index + 1 : options.length;\n\n          if (index < 0) {\n            i = max;\n          } else {\n            i = one ? index : 0;\n          } // Loop through all the selected options\n\n\n          for (; i < max; i++) {\n            option = options[i]; // Support: IE <=9 only\n            // IE8-9 doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup\n            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function set(elem, value) {\n          var optionSet,\n              option,\n              options = elem.options,\n              values = jQuery.makeArray(value),\n              i = options.length;\n\n          while (i--) {\n            option = options[i];\n            /* eslint-disable no-cond-assign */\n\n            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n              optionSet = true;\n            }\n            /* eslint-enable no-cond-assign */\n\n          } // Force browsers to behave consistently when non-matching value is set\n\n\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n\n          return values;\n        }\n      }\n    }\n  }); // Radios and checkboxes getter/setter\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = {\n      set: function set(elem, value) {\n        if (Array.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n        }\n      }\n    };\n\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n      };\n    }\n  }); // Return jQuery for attributes-only inclusion\n\n  support.focusin = \"onfocusin\" in window;\n\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      stopPropagationCallback = function stopPropagationCallback(e) {\n    e.stopPropagation();\n  };\n\n  jQuery.extend(jQuery.event, {\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var i,\n          cur,\n          tmp,\n          bubbleType,\n          ontype,\n          handle,\n          special,\n          lastElement,\n          eventPath = [elem || document],\n          type = hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") > -1) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join(\".\");\n      event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        lastElement = cur;\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (dataPriv.get(cur, \"events\") || {})[event.type] && dataPriv.get(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n          // Call a native DOM method on the target with the same name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n\n            if (event.isPropagationStopped()) {\n              lastElement.addEventListener(type, stopPropagationCallback);\n            }\n\n            elem[type]();\n\n            if (event.isPropagationStopped()) {\n              lastElement.removeEventListener(type, stopPropagationCallback);\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    // Piggyback on a donor event to simulate a different one\n    // Used only for `focus(in | out)` events\n    simulate: function simulate(type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true\n      });\n      jQuery.event.trigger(e, null, elem);\n    }\n  });\n  jQuery.fn.extend({\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  }); // Support: Firefox <=44\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\n  if (!support.focusin) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          var doc = this.ownerDocument || this,\n              attaches = dataPriv.access(doc, fix);\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n\n          dataPriv.access(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function teardown() {\n          var doc = this.ownerDocument || this,\n              attaches = dataPriv.access(doc, fix) - 1;\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n            dataPriv.remove(doc, fix);\n          } else {\n            dataPriv.access(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n\n  var location = window.location;\n  var nonce = Date.now();\n  var rquery = /\\?/; // Cross-browser xml parsing\n\n  jQuery.parseXML = function (data) {\n    var xml;\n\n    if (!data || typeof data !== \"string\") {\n      return null;\n    } // Support: IE 9 - 11 only\n    // IE throws on parseFromString with invalid input.\n\n\n    try {\n      xml = new window.DOMParser().parseFromString(data, \"text/xml\");\n    } catch (e) {\n      xml = undefined;\n    }\n\n    if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n      jQuery.error(\"Invalid XML: \" + data);\n    }\n\n    return xml;\n  };\n\n  var rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (Array.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && toType(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  } // Serialize an array of form elements or a set of\n  // key/values into a query string\n\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, valueOrFunction) {\n      // If value is a function, invoke it and use its return value\n      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n    };\n\n    if (a == null) {\n      return \"\";\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\");\n  };\n\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is( \":disabled\" ) so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (i, elem) {\n        var val = jQuery(this).val();\n\n        if (val == null) {\n          return null;\n        }\n\n        if (Array.isArray(val)) {\n          return jQuery.map(val, function (val) {\n            return {\n              name: elem.name,\n              value: val.replace(rCRLF, \"\\r\\n\")\n            };\n          });\n        }\n\n        return {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  });\n  var r20 = /%20/g,\n      rhash = /#.*$/,\n      rantiCache = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n      // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n\n  /* Prefilters\n  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n  * 2) These are called:\n  *    - BEFORE asking for a transport\n  *    - AFTER param serialization (s.data is a string if s.processData is true)\n  * 3) key is the dataType\n  * 4) the catchall symbol \"*\" can be used\n  * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n  */\n  prefilters = {},\n\n  /* Transports bindings\n  * 1) key is the dataType\n  * 2) the catchall symbol \"*\" can be used\n  * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n  */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"),\n      // Anchor tag for parsing the document origin\n  originAnchor = document.createElement(\"a\");\n  originAnchor.href = location.href; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n      if (isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var key,\n        deep,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n  /* Handles responses to an ajax request:\n  * - finds the right dataType (mediates between content-type and expected dataType)\n  * - returns the corresponding response\n  */\n\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var ct,\n        type,\n        finalDataType,\n        firstDataType,\n        contents = s.contents,\n        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  }\n  /* Chain conversions given the request and the original response\n  * Also sets the responseXXX fields on the jqXHR instance\n  */\n\n\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift(); // Convert to each sequential dataType\n\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      } // Apply the dataFilter if provided\n\n\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev; // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s[\"throws\"]) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: location.href,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": JSON.parse,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n\n      var transport,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers\n      responseHeadersString,\n          responseHeaders,\n          // timeout handle\n      timeoutTimer,\n          // Url cleanup var\n      urlAnchor,\n          // Request state (becomes false upon send and true upon completion)\n      completed,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          // Loop variable\n      i,\n          // uncached part of the url\n      uncached,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n\n          if (completed) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase() + \" \"];\n          }\n\n          return match == null ? null : match.join(\", \");\n        },\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return completed ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          if (completed == null) {\n            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (completed == null) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n\n          if (map) {\n            if (completed) {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            } else {\n              // Lazy-add the new callbacks in a way that preserves old ones\n              for (code in map) {\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n\n      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"]; // A cross-domain request is in order when the origin doesn't match the current origin.\n\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement(\"a\"); // Support: IE <=8 - 11, Edge 12 - 15\n        // IE throws exception on accessing the href property if url is malformed,\n        // e.g. http://example.com:80x/\n\n        try {\n          urlAnchor.href = s.url; // Support: IE <=8 - 11 only\n          // Anchor's host property isn't correctly set when s.url is relative\n\n          urlAnchor.href = urlAnchor.href;\n          s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n        } catch (e) {\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true;\n        }\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (completed) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      // Remove hash to simplify url manipulation\n\n      cacheURL = s.url.replace(rhash, \"\"); // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // Remember the hash so we can put it back\n        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url\n\n        if (s.data && (s.processData || typeof s.data === \"string\")) {\n          cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add or update anti-cache param if needed\n\n\n        if (s.cache === false) {\n          cacheURL = cacheURL.replace(rantiCache, \"$1\");\n          uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++ + uncached;\n        } // Put hash and anti-cache on the URL that will be requested (gh-1732)\n\n\n        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)\n      } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n        s.data = s.data.replace(r20, \"+\");\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // Aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      completeDeferred.add(s.complete);\n      jqXHR.done(s.success);\n      jqXHR.fail(s.error); // Get transport\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // If request was aborted inside ajaxSend, stop there\n\n\n        if (completed) {\n          return jqXHR;\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          completed = false;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Rethrow post-completion exceptions\n          if (completed) {\n            throw e;\n          } // Propagate others as results\n\n\n          done(-1, e);\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Ignore repeat invocations\n\n        if (completed) {\n          return;\n        }\n\n        completed = true; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // Convert no matter what (that way responseXXX fields are always set)\n\n\n        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      } // The url can be an options object (which then must have .url)\n\n\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n\n  jQuery._evalUrl = function (url, options) {\n    return jQuery.ajax({\n      url: url,\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: \"GET\",\n      dataType: \"script\",\n      cache: true,\n      async: false,\n      global: false,\n      // Only evaluate the response if it is successful (gh-4126)\n      // dataFilter is not invoked for failure responses, so using it instead\n      // of the default converter is kludgy but it works.\n      converters: {\n        \"text script\": function textScript() {}\n      },\n      dataFilter: function dataFilter(response) {\n        jQuery.globalEval(response, options);\n      }\n    });\n  };\n\n  jQuery.fn.extend({\n    wrapAll: function wrapAll(html) {\n      var wrap;\n\n      if (this[0]) {\n        if (isFunction(html)) {\n          html = html.call(this[0]);\n        } // The elements to wrap the target around\n\n\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstElementChild) {\n            elem = elem.firstElementChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var htmlIsFunction = isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap(selector) {\n      this.parent(selector).not(\"body\").each(function () {\n        jQuery(this).replaceWith(this.childNodes);\n      });\n      return this;\n    }\n  });\n\n  jQuery.expr.pseudos.hidden = function (elem) {\n    return !jQuery.expr.pseudos.visible(elem);\n  };\n\n  jQuery.expr.pseudos.visible = function (elem) {\n    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n  };\n\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  };\n\n  var xhrSuccessStatus = {\n    // File protocol always yields status code 0, assume 200\n    0: 200,\n    // Support: IE <=9 only\n    // #1450: sometimes IE returns 1223 when it should be 204\n    1223: 204\n  },\n      xhrSupported = jQuery.ajaxSettings.xhr();\n  support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  support.ajax = xhrSupported = !!xhrSupported;\n  jQuery.ajaxTransport(function (options) {\n    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest\n\n\n    if (support.cors || xhrSupported && !options.crossDomain) {\n      return {\n        send: function send(headers, complete) {\n          var i,\n              xhr = options.xhr();\n          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided\n\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i];\n            }\n          } // Override mime type if needed\n\n\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType);\n          } // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n\n\n          if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n            headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n          } // Set headers\n\n\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i]);\n          } // Callback\n\n\n          _callback = function callback(type) {\n            return function () {\n              if (_callback) {\n                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n\n                if (type === \"abort\") {\n                  xhr.abort();\n                } else if (type === \"error\") {\n                  // Support: IE <=9 only\n                  // On a manual native abort, IE9 throws\n                  // errors on any property access that is not readyState\n                  if (typeof xhr.status !== \"number\") {\n                    complete(0, \"error\");\n                  } else {\n                    complete( // File: protocol always yields status 0; see #8605, #14207\n                    xhr.status, xhr.statusText);\n                  }\n                } else {\n                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only\n                  // IE9 has no XHR2 but throws on binary (trac-11426)\n                  // For XHR2 non-text, let the caller handle it (gh-2498)\n                  (xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? {\n                    binary: xhr.response\n                  } : {\n                    text: xhr.responseText\n                  }, xhr.getAllResponseHeaders());\n                }\n              }\n            };\n          }; // Listen to events\n\n\n          xhr.onload = _callback();\n          errorCallback = xhr.onerror = xhr.ontimeout = _callback(\"error\"); // Support: IE 9 only\n          // Use onreadystatechange to replace onabort\n          // to handle uncaught aborts\n\n          if (xhr.onabort !== undefined) {\n            xhr.onabort = errorCallback;\n          } else {\n            xhr.onreadystatechange = function () {\n              // Check readyState before timeout as it changes\n              if (xhr.readyState === 4) {\n                // Allow onerror to be called first,\n                // but that will not handle a native abort\n                // Also, save errorCallback to a variable\n                // as xhr.onerror cannot be accessed\n                window.setTimeout(function () {\n                  if (_callback) {\n                    errorCallback();\n                  }\n                });\n              }\n            };\n          } // Create the abort callback\n\n\n          _callback = _callback(\"abort\");\n\n          try {\n            // Do send the request (this may raise an exception)\n            xhr.send(options.hasContent && options.data || null);\n          } catch (e) {\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (_callback) {\n              throw e;\n            }\n          }\n        },\n        abort: function abort() {\n          if (_callback) {\n            _callback();\n          }\n        }\n      };\n    }\n  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\n  jQuery.ajaxPrefilter(function (s) {\n    if (s.crossDomain) {\n      s.contents.script = false;\n    }\n  }); // Install script dataType\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and crossDomain\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain or forced-by-attrs requests\n    if (s.crossDomain || s.scriptAttrs) {\n      var script, _callback2;\n\n      return {\n        send: function send(_, complete) {\n          script = jQuery(\"<script>\").attr(s.scriptAttrs || {}).prop({\n            charset: s.scriptCharset,\n            src: s.url\n          }).on(\"load error\", _callback2 = function callback(evt) {\n            script.remove();\n            _callback2 = null;\n\n            if (evt) {\n              complete(evt.type === \"error\" ? 404 : 200, evt.type);\n            }\n          }); // Use native DOM manipulation to avoid our domManip AJAX trickery\n\n          document.head.appendChild(script[0]);\n        },\n        abort: function abort() {\n          if (_callback2) {\n            _callback2();\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // Force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten;\n        } // Save back as free\n\n\n        if (s[callbackName]) {\n          // Make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  }); // Support: Safari 8 only\n  // In Safari 8 documents created via document.implementation.createHTMLDocument\n  // collapse sibling forms: the second one becomes a child of the first one.\n  // Because of that, this security measure has to be disabled in Safari 8.\n  // https://bugs.webkit.org/show_bug.cgi?id=137337\n\n  support.createHTMLDocument = function () {\n    var body = document.implementation.createHTMLDocument(\"\").body;\n    body.innerHTML = \"<form></form><form></form>\";\n    return body.childNodes.length === 2;\n  }(); // Argument \"data\" should be string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n\n\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (typeof data !== \"string\") {\n      return [];\n    }\n\n    if (typeof context === \"boolean\") {\n      keepScripts = context;\n      context = false;\n    }\n\n    var base, parsed, scripts;\n\n    if (!context) {\n      // Stop scripts or inline event handlers from being executed immediately\n      // by using document.implementation\n      if (support.createHTMLDocument) {\n        context = document.implementation.createHTMLDocument(\"\"); // Set the base href for the created document\n        // so any parsed elements with URLs\n        // are based on the document's URL (gh-2965)\n\n        base = context.createElement(\"base\");\n        base.href = document.location.href;\n        context.head.appendChild(base);\n      } else {\n        context = document;\n      }\n    }\n\n    parsed = rsingleTag.exec(data);\n    scripts = !keepScripts && []; // Single tag\n\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n\n    parsed = buildFragment([data], context, scripts);\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n\n    return jQuery.merge([], parsed.childNodes);\n  };\n  /**\n   * Load a url into a page\n   */\n\n\n  jQuery.fn.load = function (url, params, callback) {\n    var selector,\n        type,\n        response,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off > -1) {\n      selector = stripAndCollapse(url.slice(off));\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // If \"type\" variable is undefined, then \"GET\" method will be used.\n        // Make value of this field explicit since\n        // user can override it through ajaxSetup method\n        type: type || \"GET\",\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText); // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n        // but they are ignored because response was set above.\n        // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n      }).always(callback && function (jqXHR, status) {\n        self.each(function () {\n          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n        });\n      });\n    }\n\n    return this;\n  }; // Attach a bunch of functions for handling common AJAX events\n\n\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n\n  jQuery.expr.pseudos.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = jQuery.css(elem, \"position\"),\n          curElem = jQuery(elem),\n          props = {}; // Set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, \"top\");\n      curCSSLeft = jQuery.css(elem, \"left\");\n      calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1; // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (isFunction(options)) {\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    // offset() relates an element's border box to the document origin\n    offset: function offset(options) {\n      // Preserve chaining for setter\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n\n      var rect,\n          win,\n          elem = this[0];\n\n      if (!elem) {\n        return;\n      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n      // Support: IE <=11 only\n      // Running getBoundingClientRect on a\n      // disconnected node in IE throws an error\n\n\n      if (!elem.getClientRects().length) {\n        return {\n          top: 0,\n          left: 0\n        };\n      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\n\n      rect = elem.getBoundingClientRect();\n      win = elem.ownerDocument.defaultView;\n      return {\n        top: rect.top + win.pageYOffset,\n        left: rect.left + win.pageXOffset\n      };\n    },\n    // position() relates an element's margin box to its offset parent's padding box\n    // This corresponds to the behavior of CSS absolute positioning\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          doc,\n          elem = this[0],\n          parentOffset = {\n        top: 0,\n        left: 0\n      }; // position:fixed elements are offset from the viewport, which itself always has zero offset\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = elem.getBoundingClientRect();\n      } else {\n        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n\n        doc = elem.ownerDocument;\n        offsetParent = elem.offsetParent || doc.documentElement;\n\n        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.parentNode;\n        }\n\n        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n          // Incorporate borders into its offset, since they are outside its content origin\n          parentOffset = jQuery(offsetParent).offset();\n          parentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n          parentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n        }\n      } // Subtract parent offsets and element margins\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    // This method will return documentElement in the following cases:\n    // 1) For the element inside the iframe without offsetParent, this method will return\n    //    documentElement of the parent window\n    // 2) For the hidden or detached element\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\n    //\n    // but those exceptions were never presented as a real life use-cases\n    // and might be considered as more preferable results.\n    //\n    // This logic, however, is not guaranteed and can change at any point in the future\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent;\n\n        while (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || documentElement;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = \"pageYOffset\" === prop;\n\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n        // Coalesce documents and windows\n        var win;\n\n        if (isWindow(elem)) {\n          win = elem;\n        } else if (elem.nodeType === 9) {\n          win = elem.defaultView;\n        }\n\n        if (val === undefined) {\n          return win ? win[prop] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length);\n    };\n  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n\n  jQuery.each([\"top\", \"left\"], function (i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset\n\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n      }\n    });\n  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return access(this, function (elem, type, value) {\n          var doc;\n\n          if (isWindow(elem)) {\n            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n            return funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable);\n      };\n    });\n  });\n  jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  });\n  jQuery.fn.extend({\n    hover: function hover(fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    }\n  });\n  jQuery.fn.extend({\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    }\n  }); // Bind a function to a context, optionally partially applying any\n  // arguments.\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n  // However, it is not slated for removal any time soon\n\n  jQuery.proxy = function (fn, context) {\n    var tmp, args, proxy;\n\n    if (typeof context === \"string\") {\n      tmp = fn[context];\n      context = fn;\n      fn = tmp;\n    } // Quick check to determine if target is callable, in the spec\n    // this throws a TypeError, but we will just return undefined.\n\n\n    if (!isFunction(fn)) {\n      return undefined;\n    } // Simulated bind\n\n\n    args = _slice.call(arguments, 2);\n\n    proxy = function proxy() {\n      return fn.apply(context || this, args.concat(_slice.call(arguments)));\n    }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n    return proxy;\n  };\n\n  jQuery.holdReady = function (hold) {\n    if (hold) {\n      jQuery.readyWait++;\n    } else {\n      jQuery.ready(true);\n    }\n  };\n\n  jQuery.isArray = Array.isArray;\n  jQuery.parseJSON = JSON.parse;\n  jQuery.nodeName = nodeName;\n  jQuery.isFunction = isFunction;\n  jQuery.isWindow = isWindow;\n  jQuery.camelCase = camelCase;\n  jQuery.type = toType;\n  jQuery.now = Date.now;\n\n  jQuery.isNumeric = function (obj) {\n    // As of jQuery 3.0, isNumeric is limited to\n    // strings and numbers (primitives or objects)\n    // that can be coerced to finite numbers (gh-2662)\n    var type = jQuery.type(obj);\n    return (type === \"number\" || type === \"string\") && // parseFloat NaNs numeric-cast false positives (\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    !isNaN(obj - parseFloat(obj));\n  }; // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  var // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$;\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n  }; // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n\n\n  if (!noGlobal) {\n    window.jQuery = window.$ = jQuery;\n  }\n\n  return jQuery;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvanF1ZXJ5LTMuNC4xLmpzP2IwN2QiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkb2N1bWVudCIsInciLCJFcnJvciIsIndpbmRvdyIsIm5vR2xvYmFsIiwiYXJyIiwiZ2V0UHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInNsaWNlIiwiY29uY2F0IiwicHVzaCIsImluZGV4T2YiLCJjbGFzczJ0eXBlIiwidG9TdHJpbmciLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImZuVG9TdHJpbmciLCJPYmplY3RGdW5jdGlvblN0cmluZyIsImNhbGwiLCJzdXBwb3J0IiwiaXNGdW5jdGlvbiIsIm9iaiIsIm5vZGVUeXBlIiwiaXNXaW5kb3ciLCJwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzIiwidHlwZSIsInNyYyIsIm5vbmNlIiwibm9Nb2R1bGUiLCJET01FdmFsIiwiY29kZSIsIm5vZGUiLCJkb2MiLCJpIiwidmFsIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsInRleHQiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ0b1R5cGUiLCJ2ZXJzaW9uIiwialF1ZXJ5Iiwic2VsZWN0b3IiLCJjb250ZXh0IiwiZm4iLCJpbml0IiwicnRyaW0iLCJwcm90b3R5cGUiLCJqcXVlcnkiLCJjb25zdHJ1Y3RvciIsImxlbmd0aCIsInRvQXJyYXkiLCJnZXQiLCJudW0iLCJwdXNoU3RhY2siLCJlbGVtcyIsInJldCIsIm1lcmdlIiwicHJldk9iamVjdCIsImVhY2giLCJjYWxsYmFjayIsIm1hcCIsImVsZW0iLCJhcHBseSIsImFyZ3VtZW50cyIsImZpcnN0IiwiZXEiLCJsYXN0IiwibGVuIiwiaiIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJvcHRpb25zIiwibmFtZSIsImNvcHkiLCJjb3B5SXNBcnJheSIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzUGxhaW5PYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmRlZmluZWQiLCJleHBhbmRvIiwiTWF0aCIsInJhbmRvbSIsInJlcGxhY2UiLCJpc1JlYWR5IiwiZXJyb3IiLCJtc2ciLCJub29wIiwicHJvdG8iLCJDdG9yIiwiaXNFbXB0eU9iamVjdCIsImdsb2JhbEV2YWwiLCJpc0FycmF5TGlrZSIsInRyaW0iLCJtYWtlQXJyYXkiLCJyZXN1bHRzIiwiaW5BcnJheSIsInNlY29uZCIsImdyZXAiLCJpbnZlcnQiLCJjYWxsYmFja0ludmVyc2UiLCJtYXRjaGVzIiwiY2FsbGJhY2tFeHBlY3QiLCJhcmciLCJ2YWx1ZSIsImd1aWQiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJTaXp6bGUiLCJFeHByIiwiZ2V0VGV4dCIsImlzWE1MIiwidG9rZW5pemUiLCJjb21waWxlIiwic2VsZWN0Iiwib3V0ZXJtb3N0Q29udGV4dCIsInNvcnRJbnB1dCIsImhhc0R1cGxpY2F0ZSIsInNldERvY3VtZW50IiwiZG9jRWxlbSIsImRvY3VtZW50SXNIVE1MIiwicmJ1Z2d5UVNBIiwicmJ1Z2d5TWF0Y2hlcyIsImNvbnRhaW5zIiwiRGF0ZSIsInByZWZlcnJlZERvYyIsImRpcnJ1bnMiLCJkb25lIiwiY2xhc3NDYWNoZSIsImNyZWF0ZUNhY2hlIiwidG9rZW5DYWNoZSIsImNvbXBpbGVyQ2FjaGUiLCJub25uYXRpdmVTZWxlY3RvckNhY2hlIiwic29ydE9yZGVyIiwiYSIsImIiLCJwb3AiLCJwdXNoX25hdGl2ZSIsImxpc3QiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJyd2hpdGVzcGFjZSIsIlJlZ0V4cCIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJkZXNjZW5kIiwicnBzZXVkbyIsInJpZGVudGlmaWVyIiwibWF0Y2hFeHByIiwicmh0bWwiLCJyaW5wdXRzIiwicmhlYWRlciIsInJuYXRpdmUiLCJycXVpY2tFeHByIiwicnNpYmxpbmciLCJydW5lc2NhcGUiLCJmdW5lc2NhcGUiLCJfIiwiZXNjYXBlZCIsImVzY2FwZWRXaGl0ZXNwYWNlIiwiaGlnaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJjc3Nlc2NhcGUiLCJmY3NzZXNjYXBlIiwiY2giLCJhc0NvZGVQb2ludCIsImNoYXJDb2RlQXQiLCJ1bmxvYWRIYW5kbGVyIiwiaW5EaXNhYmxlZEZpZWxkc2V0IiwiYWRkQ29tYmluYXRvciIsImRpc2FibGVkIiwibm9kZU5hbWUiLCJkaXIiLCJuZXh0IiwiY2hpbGROb2RlcyIsImUiLCJlbHMiLCJzZWVkIiwibSIsIm5pZCIsIm1hdGNoIiwiZ3JvdXBzIiwibmV3U2VsZWN0b3IiLCJuZXdDb250ZXh0Iiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidGVzdCIsInRvU2VsZWN0b3IiLCJqb2luIiwidGVzdENvbnRleHQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicXNhRXJyb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwiY2FjaGUiLCJrZXkiLCJjYWNoZUxlbmd0aCIsInNoaWZ0IiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiZWwiLCJhZGRIYW5kbGUiLCJhdHRycyIsImhhbmRsZXIiLCJhdHRySGFuZGxlIiwic2libGluZ0NoZWNrIiwiY3VyIiwiZGlmZiIsInNvdXJjZUluZGV4IiwibmV4dFNpYmxpbmciLCJjcmVhdGVJbnB1dFBzZXVkbyIsImNyZWF0ZUJ1dHRvblBzZXVkbyIsImNyZWF0ZURpc2FibGVkUHNldWRvIiwiaXNEaXNhYmxlZCIsImNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8iLCJhcmd1bWVudCIsIm1hdGNoSW5kZXhlcyIsIm5hbWVzcGFjZSIsIm5hbWVzcGFjZVVSSSIsImRvY3VtZW50RWxlbWVudCIsImhhc0NvbXBhcmUiLCJzdWJXaW5kb3ciLCJkZWZhdWx0VmlldyIsInRvcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImNsYXNzTmFtZSIsImNyZWF0ZUNvbW1lbnQiLCJnZXRCeUlkIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJmaWx0ZXIiLCJhdHRySWQiLCJmaW5kIiwiZ2V0QXR0cmlidXRlTm9kZSIsInRhZyIsInRtcCIsImlubmVySFRNTCIsImlucHV0IiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiZGlzY29ubmVjdGVkTWF0Y2giLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImFkb3duIiwiYnVwIiwiY29tcGFyZSIsInNvcnREZXRhY2hlZCIsImF1cCIsImFwIiwiYnAiLCJ1bnNoaWZ0IiwiZXhwciIsImVsZW1lbnRzIiwiYXR0ciIsInNwZWNpZmllZCIsImVzY2FwZSIsInNlbCIsInVuaXF1ZVNvcnQiLCJkdXBsaWNhdGVzIiwiZGV0ZWN0RHVwbGljYXRlcyIsInNvcnRTdGFibGUiLCJ0ZXh0Q29udGVudCIsImZpcnN0Q2hpbGQiLCJub2RlVmFsdWUiLCJzZWxlY3RvcnMiLCJjcmVhdGVQc2V1ZG8iLCJyZWxhdGl2ZSIsInByZUZpbHRlciIsImV4Y2VzcyIsInVucXVvdGVkIiwibm9kZU5hbWVTZWxlY3RvciIsInBhdHRlcm4iLCJvcGVyYXRvciIsImNoZWNrIiwicmVzdWx0Iiwid2hhdCIsInNpbXBsZSIsImZvcndhcmQiLCJvZlR5cGUiLCJ4bWwiLCJ1bmlxdWVDYWNoZSIsIm91dGVyQ2FjaGUiLCJub2RlSW5kZXgiLCJzdGFydCIsInBhcmVudCIsInVzZUNhY2hlIiwibGFzdENoaWxkIiwidW5pcXVlSUQiLCJwc2V1ZG8iLCJhcmdzIiwic2V0RmlsdGVycyIsImlkeCIsIm1hdGNoZWQiLCJtYXRjaGVyIiwidW5tYXRjaGVkIiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImxvY2F0aW9uIiwiYWN0aXZlRWxlbWVudCIsImhhc0ZvY3VzIiwiaHJlZiIsInRhYkluZGV4IiwiY2hlY2tlZCIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsInJhZGlvIiwiY2hlY2tib3giLCJmaWxlIiwicGFzc3dvcmQiLCJpbWFnZSIsInN1Ym1pdCIsInJlc2V0IiwiZmlsdGVycyIsInBhcnNlT25seSIsInRva2VucyIsInNvRmFyIiwicHJlRmlsdGVycyIsImNhY2hlZCIsImNvbWJpbmF0b3IiLCJiYXNlIiwic2tpcCIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsIm9sZENhY2hlIiwibmV3Q2FjaGUiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwibXVsdGlwbGVDb250ZXh0cyIsImNvbnRleHRzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJ0ZW1wIiwicHJlTWFwIiwicG9zdE1hcCIsInByZWV4aXN0aW5nIiwibWF0Y2hlckluIiwibWF0Y2hlck91dCIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJvdXRlcm1vc3QiLCJtYXRjaGVkQ291bnQiLCJzZXRNYXRjaGVkIiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJ0b2tlbiIsImNvbXBpbGVkIiwiZGVmYXVsdFZhbHVlIiwidW5pcXVlIiwiaXNYTUxEb2MiLCJlc2NhcGVTZWxlY3RvciIsInVudGlsIiwidHJ1bmNhdGUiLCJpcyIsInNpYmxpbmdzIiwibiIsInJuZWVkc0NvbnRleHQiLCJuZWVkc0NvbnRleHQiLCJyc2luZ2xlVGFnIiwid2lubm93IiwicXVhbGlmaWVyIiwibm90Iiwic2VsZiIsInJvb3RqUXVlcnkiLCJyb290IiwicGFyc2VIVE1MIiwicmVhZHkiLCJycGFyZW50c3ByZXYiLCJndWFyYW50ZWVkVW5pcXVlIiwiY2hpbGRyZW4iLCJjb250ZW50cyIsInByZXYiLCJoYXMiLCJ0YXJnZXRzIiwibCIsImNsb3Nlc3QiLCJpbmRleCIsInByZXZBbGwiLCJhZGQiLCJhZGRCYWNrIiwic2libGluZyIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJuZXh0QWxsIiwibmV4dFVudGlsIiwicHJldlVudGlsIiwiY29udGVudERvY3VtZW50IiwiY29udGVudCIsInJldmVyc2UiLCJybm90aHRtbHdoaXRlIiwiY3JlYXRlT3B0aW9ucyIsIm9iamVjdCIsImZsYWciLCJDYWxsYmFja3MiLCJmaXJpbmciLCJtZW1vcnkiLCJmaXJlZCIsImxvY2tlZCIsInF1ZXVlIiwiZmlyaW5nSW5kZXgiLCJmaXJlIiwib25jZSIsInN0b3BPbkZhbHNlIiwicmVtb3ZlIiwiZW1wdHkiLCJkaXNhYmxlIiwibG9jayIsImZpcmVXaXRoIiwiSWRlbnRpdHkiLCJ2IiwiVGhyb3dlciIsImV4IiwiYWRvcHRWYWx1ZSIsInJlc29sdmUiLCJyZWplY3QiLCJub1ZhbHVlIiwibWV0aG9kIiwicHJvbWlzZSIsImZhaWwiLCJ0aGVuIiwiRGVmZXJyZWQiLCJmdW5jIiwidHVwbGVzIiwic3RhdGUiLCJhbHdheXMiLCJkZWZlcnJlZCIsInBpcGUiLCJmbnMiLCJuZXdEZWZlciIsInR1cGxlIiwicmV0dXJuZWQiLCJwcm9ncmVzcyIsIm5vdGlmeSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsIm9uUHJvZ3Jlc3MiLCJtYXhEZXB0aCIsImRlcHRoIiwic3BlY2lhbCIsInRoYXQiLCJtaWdodFRocm93IiwiVHlwZUVycm9yIiwibm90aWZ5V2l0aCIsInJlc29sdmVXaXRoIiwicHJvY2VzcyIsImV4Y2VwdGlvbkhvb2siLCJzdGFja1RyYWNlIiwicmVqZWN0V2l0aCIsImdldFN0YWNrSG9vayIsInNldFRpbWVvdXQiLCJzdGF0ZVN0cmluZyIsIndoZW4iLCJzaW5nbGVWYWx1ZSIsInJlbWFpbmluZyIsInJlc29sdmVDb250ZXh0cyIsInJlc29sdmVWYWx1ZXMiLCJtYXN0ZXIiLCJ1cGRhdGVGdW5jIiwicmVycm9yTmFtZXMiLCJzdGFjayIsImNvbnNvbGUiLCJ3YXJuIiwibWVzc2FnZSIsInJlYWR5RXhjZXB0aW9uIiwicmVhZHlMaXN0IiwicmVhZHlXYWl0Iiwid2FpdCIsImNvbXBsZXRlZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkeVN0YXRlIiwiZG9TY3JvbGwiLCJhY2Nlc3MiLCJjaGFpbmFibGUiLCJlbXB0eUdldCIsInJhdyIsImJ1bGsiLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsImFsbCIsImxldHRlciIsInRvVXBwZXJDYXNlIiwiY2FtZWxDYXNlIiwic3RyaW5nIiwiYWNjZXB0RGF0YSIsIm93bmVyIiwiRGF0YSIsInVpZCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwic2V0IiwiZGF0YSIsInByb3AiLCJoYXNEYXRhIiwiZGF0YVByaXYiLCJkYXRhVXNlciIsInJicmFjZSIsInJtdWx0aURhc2giLCJnZXREYXRhIiwiSlNPTiIsInBhcnNlIiwiZGF0YUF0dHIiLCJyZW1vdmVEYXRhIiwiX2RhdGEiLCJfcmVtb3ZlRGF0YSIsImRlcXVldWUiLCJzdGFydExlbmd0aCIsImhvb2tzIiwiX3F1ZXVlSG9va3MiLCJzdG9wIiwic2V0dGVyIiwiY2xlYXJRdWV1ZSIsImNvdW50IiwiZGVmZXIiLCJwbnVtIiwic291cmNlIiwicmNzc051bSIsImNzc0V4cGFuZCIsImlzQXR0YWNoZWQiLCJjb21wb3NlZCIsImdldFJvb3ROb2RlIiwiaXNIaWRkZW5XaXRoaW5UcmVlIiwic3R5bGUiLCJkaXNwbGF5IiwiY3NzIiwic3dhcCIsIm9sZCIsImFkanVzdENTUyIsInZhbHVlUGFydHMiLCJ0d2VlbiIsImFkanVzdGVkIiwic2NhbGUiLCJtYXhJdGVyYXRpb25zIiwiY3VycmVudFZhbHVlIiwiaW5pdGlhbCIsInVuaXQiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0IiwiZGVmYXVsdERpc3BsYXlNYXAiLCJnZXREZWZhdWx0RGlzcGxheSIsImJvZHkiLCJzaG93SGlkZSIsInNob3ciLCJ2YWx1ZXMiLCJoaWRlIiwidG9nZ2xlIiwicmNoZWNrYWJsZVR5cGUiLCJydGFnTmFtZSIsInJzY3JpcHRUeXBlIiwid3JhcE1hcCIsIm9wdGlvbiIsInRoZWFkIiwiY29sIiwidHIiLCJ0ZCIsIl9kZWZhdWx0Iiwib3B0Z3JvdXAiLCJ0Ym9keSIsInRmb290IiwiY29sZ3JvdXAiLCJjYXB0aW9uIiwidGgiLCJnZXRBbGwiLCJzZXRHbG9iYWxFdmFsIiwicmVmRWxlbWVudHMiLCJidWlsZEZyYWdtZW50Iiwic2NyaXB0cyIsInNlbGVjdGlvbiIsImlnbm9yZWQiLCJ3cmFwIiwiYXR0YWNoZWQiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJub2RlcyIsImNyZWF0ZVRleHROb2RlIiwiaHRtbFByZWZpbHRlciIsImRpdiIsImNoZWNrQ2xvbmUiLCJjbG9uZU5vZGUiLCJub0Nsb25lQ2hlY2tlZCIsInJrZXlFdmVudCIsInJtb3VzZUV2ZW50IiwicnR5cGVuYW1lc3BhY2UiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJleHBlY3RTeW5jIiwic2FmZUFjdGl2ZUVsZW1lbnQiLCJlcnIiLCJvbiIsInR5cGVzIiwib25lIiwib3JpZ0ZuIiwiZXZlbnQiLCJvZmYiLCJoYW5kbGVPYmpJbiIsImV2ZW50SGFuZGxlIiwiZXZlbnRzIiwidCIsImhhbmRsZU9iaiIsImhhbmRsZXJzIiwibmFtZXNwYWNlcyIsIm9yaWdUeXBlIiwiZWxlbURhdGEiLCJoYW5kbGUiLCJ0cmlnZ2VyZWQiLCJkaXNwYXRjaCIsImRlbGVnYXRlVHlwZSIsImJpbmRUeXBlIiwiZGVsZWdhdGVDb3VudCIsInNldHVwIiwibWFwcGVkVHlwZXMiLCJvcmlnQ291bnQiLCJ0ZWFyZG93biIsInJlbW92ZUV2ZW50IiwibmF0aXZlRXZlbnQiLCJmaXgiLCJoYW5kbGVyUXVldWUiLCJkZWxlZ2F0ZVRhcmdldCIsInByZURpc3BhdGNoIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJtYXRjaGVkSGFuZGxlcnMiLCJtYXRjaGVkU2VsZWN0b3JzIiwiYnV0dG9uIiwiYWRkUHJvcCIsImhvb2siLCJFdmVudCIsImVudW1lcmFibGUiLCJvcmlnaW5hbEV2ZW50Iiwid3JpdGFibGUiLCJsb2FkIiwibm9CdWJibGUiLCJjbGljayIsImxldmVyYWdlTmF0aXZlIiwidHJpZ2dlciIsImJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwibm90QXN5bmMiLCJzYXZlZCIsImlzVHJpZ2dlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInByb3BzIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInJlbGF0ZWRUYXJnZXQiLCJ0aW1lU3RhbXAiLCJub3ciLCJpc1NpbXVsYXRlZCIsImFsdEtleSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJjdHJsS2V5IiwiZGV0YWlsIiwiZXZlbnRQaGFzZSIsIm1ldGFLZXkiLCJwYWdlWCIsInBhZ2VZIiwic2hpZnRLZXkiLCJ2aWV3IiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiYnV0dG9ucyIsImNsaWVudFgiLCJjbGllbnRZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJwb2ludGVySWQiLCJwb2ludGVyVHlwZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwidGFyZ2V0VG91Y2hlcyIsInRvRWxlbWVudCIsInRvdWNoZXMiLCJ3aGljaCIsImZvY3VzIiwiYmx1ciIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwib3JpZyIsInJlbGF0ZWQiLCJyeGh0bWxUYWciLCJybm9Jbm5lcmh0bWwiLCJyY2hlY2tlZCIsInJjbGVhblNjcmlwdCIsIm1hbmlwdWxhdGlvblRhcmdldCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0IiwicGRhdGFPbGQiLCJwZGF0YUN1ciIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiY29sbGVjdGlvbiIsImhhc1NjcmlwdHMiLCJpTm9DbG9uZSIsInZhbHVlSXNGdW5jdGlvbiIsImh0bWwiLCJfZXZhbFVybCIsImtlZXBEYXRhIiwiY2xlYW5EYXRhIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwic3JjRWxlbWVudHMiLCJkZXN0RWxlbWVudHMiLCJpblBhZ2UiLCJkZXRhY2giLCJhcHBlbmQiLCJwcmVwZW5kIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwib3JpZ2luYWwiLCJpbnNlcnQiLCJybnVtbm9ucHgiLCJnZXRTdHlsZXMiLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwicmJveFN0eWxlIiwiY29tcHV0ZVN0eWxlVGVzdHMiLCJjb250YWluZXIiLCJjc3NUZXh0IiwiZGl2U3R5bGUiLCJwaXhlbFBvc2l0aW9uVmFsIiwicmVsaWFibGVNYXJnaW5MZWZ0VmFsIiwicm91bmRQaXhlbE1lYXN1cmVzIiwibWFyZ2luTGVmdCIsInJpZ2h0IiwicGl4ZWxCb3hTdHlsZXNWYWwiLCJib3hTaXppbmdSZWxpYWJsZVZhbCIsIndpZHRoIiwicG9zaXRpb24iLCJzY3JvbGxib3hTaXplVmFsIiwib2Zmc2V0V2lkdGgiLCJtZWFzdXJlIiwicm91bmQiLCJwYXJzZUZsb2F0IiwiYmFja2dyb3VuZENsaXAiLCJjbGVhckNsb25lU3R5bGUiLCJib3hTaXppbmdSZWxpYWJsZSIsInBpeGVsQm94U3R5bGVzIiwicGl4ZWxQb3NpdGlvbiIsInJlbGlhYmxlTWFyZ2luTGVmdCIsInNjcm9sbGJveFNpemUiLCJjdXJDU1MiLCJjb21wdXRlZCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYWRkR2V0SG9va0lmIiwiY29uZGl0aW9uRm4iLCJob29rRm4iLCJjc3NQcmVmaXhlcyIsImVtcHR5U3R5bGUiLCJ2ZW5kb3JQcm9wcyIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsImZpbmFsUHJvcE5hbWUiLCJmaW5hbCIsImNzc1Byb3BzIiwicmRpc3BsYXlzd2FwIiwicmN1c3RvbVByb3AiLCJjc3NTaG93IiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJmb250V2VpZ2h0Iiwic2V0UG9zaXRpdmVOdW1iZXIiLCJzdWJ0cmFjdCIsIm1heCIsImJveE1vZGVsQWRqdXN0bWVudCIsImRpbWVuc2lvbiIsImJveCIsImlzQm9yZGVyQm94Iiwic3R5bGVzIiwiY29tcHV0ZWRWYWwiLCJleHRyYSIsImRlbHRhIiwiY2VpbCIsImdldFdpZHRoT3JIZWlnaHQiLCJib3hTaXppbmdOZWVkZWQiLCJ2YWx1ZUlzQm9yZGVyQm94Iiwib2Zmc2V0UHJvcCIsImdldENsaWVudFJlY3RzIiwiY3NzSG9va3MiLCJvcGFjaXR5Iiwib3JpZ05hbWUiLCJpc0N1c3RvbVByb3AiLCJzZXRQcm9wZXJ0eSIsImlzRmluaXRlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsYm94U2l6ZUJ1Z2d5IiwibGVmdCIsIm1hcmdpbiIsInBhZGRpbmciLCJib3JkZXIiLCJwcmVmaXgiLCJzdWZmaXgiLCJleHBhbmQiLCJleHBhbmRlZCIsInBhcnRzIiwiVHdlZW4iLCJlYXNpbmciLCJwcm9wSG9va3MiLCJydW4iLCJwZXJjZW50IiwiZWFzZWQiLCJkdXJhdGlvbiIsInBvcyIsInN0ZXAiLCJmeCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJsaW5lYXIiLCJwIiwic3dpbmciLCJjb3MiLCJQSSIsImZ4Tm93IiwiaW5Qcm9ncmVzcyIsInJmeHR5cGVzIiwicnJ1biIsInNjaGVkdWxlIiwiaGlkZGVuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaW50ZXJ2YWwiLCJ0aWNrIiwiY3JlYXRlRnhOb3ciLCJnZW5GeCIsImluY2x1ZGVXaWR0aCIsImhlaWdodCIsImNyZWF0ZVR3ZWVuIiwiYW5pbWF0aW9uIiwiQW5pbWF0aW9uIiwidHdlZW5lcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwib3B0cyIsIm9sZGZpcmUiLCJwcm9wVHdlZW4iLCJyZXN0b3JlRGlzcGxheSIsImlzQm94IiwiYW5pbSIsImRhdGFTaG93IiwidW5xdWV1ZWQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInByb3BGaWx0ZXIiLCJzcGVjaWFsRWFzaW5nIiwicHJvcGVydGllcyIsInN0b3BwZWQiLCJwcmVmaWx0ZXJzIiwiY3VycmVudFRpbWUiLCJzdGFydFRpbWUiLCJ0d2VlbnMiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJvcmlnaW5hbE9wdGlvbnMiLCJnb3RvRW5kIiwiYmluZCIsImNvbXBsZXRlIiwidGltZXIiLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwic3BlZWQiLCJvcHQiLCJzcGVlZHMiLCJmYWRlVG8iLCJ0byIsImFuaW1hdGUiLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImNzc0ZuIiwic2xpZGVEb3duIiwic2xpZGVVcCIsInNsaWRlVG9nZ2xlIiwiZmFkZUluIiwiZmFkZU91dCIsImZhZGVUb2dnbGUiLCJzbG93IiwiZmFzdCIsImRlbGF5IiwidGltZSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjaGVja09uIiwib3B0U2VsZWN0ZWQiLCJyYWRpb1ZhbHVlIiwiYm9vbEhvb2siLCJyZW1vdmVBdHRyIiwiblR5cGUiLCJhdHRySG9va3MiLCJib29sIiwiYXR0ck5hbWVzIiwiZ2V0dGVyIiwibG93ZXJjYXNlTmFtZSIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicmVtb3ZlUHJvcCIsInByb3BGaXgiLCJ0YWJpbmRleCIsInBhcnNlSW50Iiwic3RyaXBBbmRDb2xsYXBzZSIsImdldENsYXNzIiwiY2xhc3Nlc1RvQXJyYXkiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJjdXJWYWx1ZSIsImNsYXp6IiwiZmluYWxWYWx1ZSIsInJlbW92ZUNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJzdGF0ZVZhbCIsImlzVmFsaWRWYWx1ZSIsImNsYXNzTmFtZXMiLCJoYXNDbGFzcyIsInJyZXR1cm4iLCJ2YWxIb29rcyIsIm9wdGlvblNldCIsImZvY3VzaW4iLCJyZm9jdXNNb3JwaCIsInN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrIiwib25seUhhbmRsZXJzIiwiYnViYmxlVHlwZSIsIm9udHlwZSIsImxhc3RFbGVtZW50IiwiZXZlbnRQYXRoIiwicGFyZW50V2luZG93Iiwic2ltdWxhdGUiLCJ0cmlnZ2VySGFuZGxlciIsImF0dGFjaGVzIiwicnF1ZXJ5IiwicGFyc2VYTUwiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwiYnVpbGRQYXJhbXMiLCJ0cmFkaXRpb25hbCIsInBhcmFtIiwicyIsInZhbHVlT3JGdW5jdGlvbiIsImVuY29kZVVSSUNvbXBvbmVudCIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZUFycmF5IiwicjIwIiwicmhhc2giLCJyYW50aUNhY2hlIiwicmhlYWRlcnMiLCJybG9jYWxQcm90b2NvbCIsInJub0NvbnRlbnQiLCJycHJvdG9jb2wiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJvcmlnaW5BbmNob3IiLCJhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJzdHJ1Y3R1cmUiLCJkYXRhVHlwZUV4cHJlc3Npb24iLCJkYXRhVHlwZSIsImRhdGFUeXBlcyIsImluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwianFYSFIiLCJpbnNwZWN0ZWQiLCJzZWVraW5nVHJhbnNwb3J0IiwiaW5zcGVjdCIsInByZWZpbHRlck9yRmFjdG9yeSIsImRhdGFUeXBlT3JUcmFuc3BvcnQiLCJhamF4RXh0ZW5kIiwiZmxhdE9wdGlvbnMiLCJhamF4U2V0dGluZ3MiLCJhamF4SGFuZGxlUmVzcG9uc2VzIiwicmVzcG9uc2VzIiwiY3QiLCJmaW5hbERhdGFUeXBlIiwiZmlyc3REYXRhVHlwZSIsIm1pbWVUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJjb252ZXJ0ZXJzIiwiYWpheENvbnZlcnQiLCJyZXNwb25zZSIsImlzU3VjY2VzcyIsImNvbnYyIiwiY3VycmVudCIsImNvbnYiLCJyZXNwb25zZUZpZWxkcyIsImRhdGFGaWx0ZXIiLCJhY3RpdmUiLCJsYXN0TW9kaWZpZWQiLCJldGFnIiwidXJsIiwiaXNMb2NhbCIsInByb3RvY29sIiwicHJvY2Vzc0RhdGEiLCJhc3luYyIsImNvbnRlbnRUeXBlIiwiYWNjZXB0cyIsImpzb24iLCJhamF4U2V0dXAiLCJzZXR0aW5ncyIsImFqYXhQcmVmaWx0ZXIiLCJhamF4VHJhbnNwb3J0IiwiYWpheCIsInRyYW5zcG9ydCIsImNhY2hlVVJMIiwicmVzcG9uc2VIZWFkZXJzU3RyaW5nIiwicmVzcG9uc2VIZWFkZXJzIiwidGltZW91dFRpbWVyIiwidXJsQW5jaG9yIiwiZmlyZUdsb2JhbHMiLCJ1bmNhY2hlZCIsImNhbGxiYWNrQ29udGV4dCIsImdsb2JhbEV2ZW50Q29udGV4dCIsImNvbXBsZXRlRGVmZXJyZWQiLCJzdGF0dXNDb2RlIiwicmVxdWVzdEhlYWRlcnMiLCJyZXF1ZXN0SGVhZGVyc05hbWVzIiwic3RyQWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib3ZlcnJpZGVNaW1lVHlwZSIsInN0YXR1cyIsImFib3J0Iiwic3RhdHVzVGV4dCIsImZpbmFsVGV4dCIsImNyb3NzRG9tYWluIiwiaG9zdCIsImhhc0NvbnRlbnQiLCJpZk1vZGlmaWVkIiwiaGVhZGVycyIsImJlZm9yZVNlbmQiLCJzdWNjZXNzIiwic2VuZCIsIm5hdGl2ZVN0YXR1c1RleHQiLCJtb2RpZmllZCIsImdldEpTT04iLCJnZXRTY3JpcHQiLCJ3cmFwQWxsIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJ3cmFwSW5uZXIiLCJodG1sSXNGdW5jdGlvbiIsInVud3JhcCIsInZpc2libGUiLCJvZmZzZXRIZWlnaHQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsIm9wZW4iLCJ1c2VybmFtZSIsInhockZpZWxkcyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJvbmFib3J0Iiwib250aW1lb3V0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0IiwiYmluYXJ5Iiwic2NyaXB0QXR0cnMiLCJjaGFyc2V0Iiwic2NyaXB0Q2hhcnNldCIsImV2dCIsIm9sZENhbGxiYWNrcyIsInJqc29ucCIsImpzb25wIiwianNvbnBDYWxsYmFjayIsIm9yaWdpbmFsU2V0dGluZ3MiLCJjYWxsYmFja05hbWUiLCJvdmVyd3JpdHRlbiIsInJlc3BvbnNlQ29udGFpbmVyIiwianNvblByb3AiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImtlZXBTY3JpcHRzIiwicGFyc2VkIiwicGFyYW1zIiwiYW5pbWF0ZWQiLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJjdXJQb3NpdGlvbiIsImN1ckxlZnQiLCJjdXJDU1NUb3AiLCJjdXJUb3AiLCJjdXJPZmZzZXQiLCJjdXJDU1NMZWZ0IiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjdXJFbGVtIiwidXNpbmciLCJyZWN0Iiwid2luIiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsImhvdmVyIiwiZm5PdmVyIiwiZm5PdXQiLCJ1bmJpbmQiLCJkZWxlZ2F0ZSIsInVuZGVsZWdhdGUiLCJwcm94eSIsImhvbGRSZWFkeSIsImhvbGQiLCJwYXJzZUpTT04iLCJpc051bWVyaWMiLCJpc05hTiIsImRlZmluZSIsIl9qUXVlcnkiLCJfJCIsIiQiLCJub0NvbmZsaWN0Il0sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7Ozs7Ozs7O0FBYUEsQ0FBRSxVQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUE0QjtBQUUxQjs7QUFFQSxNQUFLLDhCQUFPQyxNQUFQLE9BQWtCLFFBQWxCLElBQThCLFFBQU9BLE1BQU0sQ0FBQ0MsT0FBZCxNQUEwQixRQUE3RCxFQUF3RTtBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRCxVQUFNLENBQUNDLE9BQVAsR0FBaUJILE1BQU0sQ0FBQ0ksUUFBUCxHQUNiSCxPQUFPLENBQUVELE1BQUYsRUFBVSxJQUFWLENBRE0sR0FFYixVQUFVSyxDQUFWLEVBQWM7QUFDVixVQUFLLENBQUNBLENBQUMsQ0FBQ0QsUUFBUixFQUFtQjtBQUNmLGNBQU0sSUFBSUUsS0FBSixDQUFXLDBDQUFYLENBQU47QUFDSDs7QUFDRCxhQUFPTCxPQUFPLENBQUVJLENBQUYsQ0FBZDtBQUNILEtBUEw7QUFRSCxHQWpCRCxNQWlCTztBQUNISixXQUFPLENBQUVELE1BQUYsQ0FBUDtBQUNILEdBdkJ5QixDQXlCOUI7O0FBQ0MsQ0ExQkQsRUEwQkssT0FBT08sTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUMsSUExQjlDLEVBMEJvRCxVQUFVQSxNQUFWLEVBQWtCQyxRQUFs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QUM0QyxNQUhyQjtBQUFBLE1BS0k7QUFDQXVtQyxJQUFFLEdBQUducEMsTUFBTSxDQUFDb3BDLENBTmhCOztBQVFBeG1DLFFBQU0sQ0FBQ3ltQyxVQUFQLEdBQW9CLFVBQVVsa0MsSUFBVixFQUFpQjtBQUNqQyxRQUFLbkYsTUFBTSxDQUFDb3BDLENBQVAsS0FBYXhtQyxNQUFsQixFQUEyQjtBQUN2QjVDLFlBQU0sQ0FBQ29wQyxDQUFQLEdBQVdELEVBQVg7QUFDSDs7QUFFRCxRQUFLaGtDLElBQUksSUFBSW5GLE1BQU0sQ0FBQzRDLE1BQVAsS0FBa0JBLE1BQS9CLEVBQXdDO0FBQ3BDNUMsWUFBTSxDQUFDNEMsTUFBUCxHQUFnQnNtQyxPQUFoQjtBQUNIOztBQUVELFdBQU90bUMsTUFBUDtBQUNILEdBVkQsQ0F2eVU2RSxDQW16VWpGO0FBQ0E7QUFDQTs7O0FBQ0ksTUFBSyxDQUFDM0MsUUFBTixFQUFpQjtBQUNiRCxVQUFNLENBQUM0QyxNQUFQLEdBQWdCNUMsTUFBTSxDQUFDb3BDLENBQVAsR0FBV3htQyxNQUEzQjtBQUNIOztBQUtELFNBQU9BLE1BQVA7QUFDSCxDQXgxVUQsRSIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9qcXVlcnktMy40LjEuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNC4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOS0wNS0wMVQyMTowNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgIC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2BcbiAgICAgICAgLy8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cbiAgICAgICAgLy8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcbiAgICAgICAgLy8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG4gICAgICAgIC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG4gICAgICAgIC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcbiAgICAgICAgLy8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuICAgICAgICAgICAgZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuICAgICAgICAgICAgZnVuY3Rpb24oIHcgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhdy5kb2N1bWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeSggdyApO1xuICAgICAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KCBnbG9iYWwgKTtcbiAgICB9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBhcnIgPSBbXTtcblxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuICAgIHZhciBzbGljZSA9IGFyci5zbGljZTtcblxuICAgIHZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG4gICAgdmFyIHB1c2ggPSBhcnIucHVzaDtcblxuICAgIHZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbiAgICB2YXIgY2xhc3MydHlwZSA9IHt9O1xuXG4gICAgdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxuICAgIHZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgdmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbiAgICB2YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG4gICAgdmFyIHN1cHBvcnQgPSB7fTtcblxuICAgIHZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICAgIH07XG5cblxuICAgIHZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG4gICAgfTtcblxuXG5cblxuICAgIHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuICAgICAgICB0eXBlOiB0cnVlLFxuICAgICAgICBzcmM6IHRydWUsXG4gICAgICAgIG5vbmNlOiB0cnVlLFxuICAgICAgICBub01vZHVsZTogdHJ1ZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG4gICAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuICAgICAgICB2YXIgaSwgdmFsLFxuICAgICAgICAgICAgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuICAgICAgICBzY3JpcHQudGV4dCA9IGNvZGU7XG4gICAgICAgIGlmICggbm9kZSApIHtcbiAgICAgICAgICAgIGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG4gICAgICAgICAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcbiAgICAgICAgICAgICAgICAvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2ZcbiAgICAgICAgICAgICAgICAvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcbiAgICAgICAgICAgICAgICAvLyB2aWEgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xuICAgICAgICAgICAgICAgIGlmICggdmFsICkge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCBpLCB2YWwgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG4gICAgICAgIGlmICggb2JqID09IG51bGwgKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICsgXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuICAgICAgICAgICAgY2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcbiAgICAgICAgICAgIHR5cGVvZiBvYmo7XG4gICAgfVxuICAgIC8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxuICAgIHZhclxuICAgICAgICB2ZXJzaW9uID0gXCIzLjQuMVwiLFxuXG4gICAgICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG4gICAgICAgIGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuICAgICAgICAgICAgLy8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG4gICAgICAgICAgICAvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG4gICAgICAgIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4gICAgalF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG4gICAgICAgIGpxdWVyeTogdmVyc2lvbixcblxuICAgICAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuICAgICAgICBsZW5ndGg6IDAsXG5cbiAgICAgICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1JcbiAgICAgICAgLy8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG4gICAgICAgICAgICBpZiAoIG51bSA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcbiAgICAgICAgICAgIHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcbiAgICAgICAgLy8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG4gICAgICAgIHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG4gICAgICAgICAgICAvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuICAgICAgICAgICAgdmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuICAgICAgICAgICAgcmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuICAgICAgICBlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG4gICAgICAgICAgICB9ICkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKCAwICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcSggLTEgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlcTogZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cbiAgICAgICAgcHVzaDogcHVzaCxcbiAgICAgICAgc29ydDogYXJyLnNvcnQsXG4gICAgICAgIHNwbGljZTogYXJyLnNwbGljZVxuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcbiAgICAgICAgICAgIGkgPSAxLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgICAgIGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG4gICAgICAgICAgICBkZWVwID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuICAgICAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICAgICAgaWYgKCBpID09PSBsZW5ndGggKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG5cbiAgICAgICAgLy8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG4gICAgICAgIGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cbiAgICAgICAgLy8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcbiAgICAgICAgaXNSZWFkeTogdHJ1ZSxcblxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbm9vcDogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgdmFyIHByb3RvLCBDdG9yO1xuXG4gICAgICAgICAgICAvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcbiAgICAgICAgICAgIC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuICAgICAgICAgICAgaWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cbiAgICAgICAgICAgIC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cbiAgICAgICAgICAgIGlmICggIXByb3RvICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuICAgICAgICAgICAgQ3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuICAgICAgICBnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucyApIHtcbiAgICAgICAgICAgIERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoLCBpID0gMDtcblxuICAgICAgICAgICAgaWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICggaSBpbiBvYmogKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4gICAgICAgIHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgXCJcIiA6XG4gICAgICAgICAgICAgICAgKCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKCBhcnIgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBhcnIgXSA6IGFyclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbCggcmV0LCBhcnIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICBtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Lmxlbmd0aCA9IGk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgfSxcblxuICAgICAgICBncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tJbnZlcnNlLFxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG4gICAgICAgICAgICAvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG4gICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIHZhbHVlLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuICAgICAgICAgICAgaWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICggaSBpbiBlbGVtcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcbiAgICAgICAgZ3VpZDogMSxcblxuICAgICAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cbiAgICAgICAgc3VwcG9ydDogc3VwcG9ydFxuICAgIH0gKTtcblxuICAgIGlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICBqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbiAgICB9XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuICAgIGpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG4gICAgICAgIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuICAgICAgICAgICAgY2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0gKTtcblxuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuICAgICAgICAvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG4gICAgICAgIC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuICAgICAgICAvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG4gICAgICAgIHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuICAgICAgICAgICAgdHlwZSA9IHRvVHlwZSggb2JqICk7XG5cbiAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgdHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbiAgICB9XG4gICAgdmFyIFNpenpsZSA9XG4gICAgICAgIC8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy40XG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAqXG4gKiBEYXRlOiAyMDE5LTA0LTA4XG4gKi9cbiAgICAgICAgKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHN1cHBvcnQsXG4gICAgICAgICAgICAgICAgRXhwcixcbiAgICAgICAgICAgICAgICBnZXRUZXh0LFxuICAgICAgICAgICAgICAgIGlzWE1MLFxuICAgICAgICAgICAgICAgIHRva2VuaXplLFxuICAgICAgICAgICAgICAgIGNvbXBpbGUsXG4gICAgICAgICAgICAgICAgc2VsZWN0LFxuICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQsXG4gICAgICAgICAgICAgICAgc29ydElucHV0LFxuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSxcblxuICAgICAgICAgICAgICAgIC8vIExvY2FsIGRvY3VtZW50IHZhcnNcbiAgICAgICAgICAgICAgICBzZXREb2N1bWVudCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICBkb2NFbGVtLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MLFxuICAgICAgICAgICAgICAgIHJidWdneVFTQSxcbiAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgY29udGFpbnMsXG5cbiAgICAgICAgICAgICAgICAvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG4gICAgICAgICAgICAgICAgZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZGlycnVucyA9IDAsXG4gICAgICAgICAgICAgICAgZG9uZSA9IDAsXG4gICAgICAgICAgICAgICAgY2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICAgICAgdG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICAgICAgY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICAgICAgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICAgICAgc29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggYSA9PT0gYiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEluc3RhbmNlIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGFyciA9IFtdLFxuICAgICAgICAgICAgICAgIHBvcCA9IGFyci5wb3AsXG4gICAgICAgICAgICAgICAgcHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcbiAgICAgICAgICAgICAgICBwdXNoID0gYXJyLnB1c2gsXG4gICAgICAgICAgICAgICAgc2xpY2UgPSBhcnIuc2xpY2UsXG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuICAgICAgICAgICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYm9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG4gICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmF0b3IgKGNhcHR1cmUgMilcbiAgICAgICAgICAgICAgICAgICAgXCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcbiAgICAgICAgICAgICAgICAgICAgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICBcIipcXFxcXVwiLFxuXG4gICAgICAgICAgICAgICAgcHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuICAgICAgICAgICAgICAgICAgICBcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG4gICAgICAgICAgICAgICAgICAgIFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuICAgICAgICAgICAgICAgICAgICBcIi4qXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIilcXFxcKXwpXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG4gICAgICAgICAgICAgICAgcndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG4gICAgICAgICAgICAgICAgcnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG4gICAgICAgICAgICAgICAgcmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG4gICAgICAgICAgICAgICAgcmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG4gICAgICAgICAgICAgICAgcmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cbiAgICAgICAgICAgICAgICBycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuICAgICAgICAgICAgICAgIHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuICAgICAgICAgICAgICAgIG1hdGNoRXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG4gICAgICAgICAgICAgICAgICAgIFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuICAgICAgICAgICAgICAgICAgICBcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG4gICAgICAgICAgICAgICAgICAgIFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuICAgICAgICAgICAgICAgICAgICBcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuICAgICAgICAgICAgICAgICAgICBcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcbiAgICAgICAgICAgICAgICAgICAgXCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByaHRtbCA9IC9IVE1MJC9pLFxuICAgICAgICAgICAgICAgIHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuICAgICAgICAgICAgICAgIHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cbiAgICAgICAgICAgICAgICBybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuICAgICAgICAgICAgICAgIC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgIHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuICAgICAgICAgICAgICAgIHJzaWJsaW5nID0gL1srfl0vLFxuXG4gICAgICAgICAgICAgICAgLy8gQ1NTIGVzY2FwZXNcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgcnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcbiAgICAgICAgICAgICAgICBmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaCA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJNUCBjb2RlcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcbiAgICAgICAgICAgICAgICByY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG4gICAgICAgICAgICAgICAgZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggYXNDb2RlUG9pbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBjaDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gVXNlZCBmb3IgaWZyYW1lc1xuICAgICAgICAgICAgICAgIC8vIFNlZSBzZXREb2N1bWVudCgpXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgaW4gSUVcbiAgICAgICAgICAgICAgICB1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZpZWxkc2V0XCI7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG4gICAgICAgICAgICAgICAgKTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgKGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjBcbiAgICAgICAgICAgICAgICAvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG4gICAgICAgICAgICAgICAgYXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgICAgIHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuICAgICAgICAgICAgICAgIGlmICggIXNlZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KCBjb250ZXh0ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRCBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5pZCA9PT0gbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5pZCA9PT0gbSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3VwcG9ydC5xc2EgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSAmJlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOCBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlVHlwZSA9PT0gMSAmJiByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggcXNhRXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBbGwgb3RoZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gICAgICAgICAgICAgKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAgICAgICAgICAgICAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgICAgICBmblsgZXhwYW5kbyBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFmbiggZWwgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuICAgICAgICAgICAgICAgICAgICBlbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG4gICAgICAgICAgICAgICAgICAgIGkgPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgIEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyID0gYiAmJiBhLFxuICAgICAgICAgICAgICAgICAgICBkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoIGRpZmYgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG4gICAgICAgICAgICAgICAgaWYgKCBjdXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ciA9PT0gYiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTggKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICAgICAgICAgICAgICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG4gICAgICAgICAgICB9XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG4gICAgICAgICAgICBzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXRlY3RzIFhNTCBub2Rlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG4gICAgICAgICAgICAgICAgICAgIGRvY0VsZW0gPSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OFxuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZSBsb2FkaW5nIGlmcmFtZXNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuICAgICAgICAgICAgICAgIHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IGRvYztcbiAgICAgICAgICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcbiAgICAgICAgICAgICAgICBpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEsIEVkZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gXCJpXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDEwXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG4gICAgICAgICAgICAgICAgLy8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG4gICAgICAgICAgICAgICAgc3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSUQgZmlsdGVyIGFuZCBmaW5kXG4gICAgICAgICAgICAgICAgaWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgRXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcbiAgICAgICAgICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBpLCBlbGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBlbGVtIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGVsZW0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUYWdcbiAgICAgICAgICAgICAgICBFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGFnID09PSBcIipcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIENsYXNzXG4gICAgICAgICAgICAgICAgRXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgICAgICAgICAvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cbiAgICAgICAgICAgICAgICAvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuICAgICAgICAgICAgICAgIHJidWdneVFTQSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIFFTQSByZWdleFxuICAgICAgICAgICAgICAgICAgICAvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwifj1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRThcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTktMTErXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG4gICAgICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuICAgICAgICAgICAgICAgIC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgICAgICAgICBoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcbiAgICAgICAgICAgICAgICAvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcbiAgICAgICAgICAgICAgICAvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuICAgICAgICAgICAgICAgIGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMoIGJ1cCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGIgPT09IGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuICAgICAgICAgICAgICAgIHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYSA9PT0gYiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbXBhcmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wYXJlICYgMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnB1dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGEgPT09IGIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXAgPSBhLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVwID0gYi5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwID0gWyBhIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnAgPSBbIGIgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWF1cCB8fCAhYnVwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9PT0gZG9jdW1lbnQgPyAxIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1cCA/IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXAgPyAxIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydElucHV0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcC51bnNoaWZ0KCBjdXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnAudW5zaGlmdCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG4gICAgICAgICAgICAgICAgICAgICFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuICAgICAgICAgICAgICAgICAgICAoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG4gICAgICAgICAgICAgICAgICAgICggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFnbWVudCBpbiBJRSA5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggY29udGV4dCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggZWxlbSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgdmFsIDpcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG4gICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcbiAgICAgICAgICAgICAgICBzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBoYXNEdXBsaWNhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggai0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcbiAgICAgICAgICAgICAgICBzb3J0SW5wdXQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFub2RlVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGdldFRleHQoIG5vZGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuICAgICAgICAgICAgICAgIC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuICAgICAgICAgICAgICAgIGNhY2hlTGVuZ3RoOiA1MCxcblxuICAgICAgICAgICAgICAgIGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNoRXhwcixcblxuICAgICAgICAgICAgICAgIGF0dHJIYW5kbGU6IHt9LFxuXG4gICAgICAgICAgICAgICAgZmluZDoge30sXG5cbiAgICAgICAgICAgICAgICByZWxhdGl2ZToge1xuICAgICAgICAgICAgICAgICAgICBcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICBcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcHJlRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaFszXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4Y2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaFszXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuXG4gICAgICAgICAgICAgICAgICAgIFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3BlcmF0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2ltcGxlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggZGlyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2ZUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB1c2VDYWNoZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkaWZmID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggb2ZUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZGlmZiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHVzZUNhY2hlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZSA9PT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiAtPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBhcyBTaXp6bGUgZG9lc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmblsgZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbiggYXJndW1lbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBwc2V1ZG9zOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuICAgICAgICAgICAgICAgICAgICBcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBzZWVkLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0WzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFswXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICBcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cbiAgICAgICAgICAgICAgICAgICAgXCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtTGFuZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5sYW5nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xuICAgICAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuICAgICAgICAgICAgICAgICAgICBcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgICAgICAgICAgICAgXCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgXCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgXCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgMCBdO1xuICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICBcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBsZW5ndGggLSAxIF07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICBcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgKyBsZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID4gbGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IC0taSA+PSAwOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG4gICAgICAgICAgICBmb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcbiAgICAgICAgICAgICAgICBFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuICAgICAgICAgICAgICAgIEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG4gICAgICAgICAgICB9XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuICAgICAgICAgICAgZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG4gICAgICAgICAgICBzZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbiAgICAgICAgICAgIEV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbiAgICAgICAgICAgIHRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuICAgICAgICAgICAgICAgIGlmICggY2FjaGVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNvRmFyID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgZ3JvdXBzID0gW107XG4gICAgICAgICAgICAgICAgcHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBzb0ZhciApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbWF0Y2hlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUganVzdCBwYXJzaW5nXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/XG4gICAgICAgICAgICAgICAgICAgIHNvRmFyLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgIHNvRmFyID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuICAgICAgICAgICAgICAgICAgICBza2lwID0gY29tYmluYXRvci5uZXh0LFxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBza2lwIHx8IGRpcixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgZG9uZU5hbWUgPSBkb25lKys7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICBuZXdVbm1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hcHBlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAsIGksIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVNYXAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNYXAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlckluO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwb3N0RmlsdGVyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbHRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdGVtcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbmRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPSBjb25kZW5zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbmRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcbiAgICAgICAgICAgICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0gXTtcblxuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSArK2k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRNYXRjaGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA+IDEgJiYgdG9TZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICAgICAgYnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG91dGVybW9zdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeG1sID0gIWRvY3VtZW50SXNIVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvdXRlcm1vc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGJ5U2V0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENvdW50ICs9IGk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1lcmljYWxseSB6ZXJvLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2VlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5tYXRjaGVkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ5U2V0ID9cbiAgICAgICAgICAgICAgICAgICAgbWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyTWF0Y2hlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuICAgICAgICAgICAgICAgIGlmICggIWNhY2hlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICAgICAgICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAgICAgICAgICAgICAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG4gICAgICAgICAgICAgICAgLy8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuICAgICAgICAgICAgICAgIGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoc2VlZCA9IGZpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG4gICAgICAgICAgICAgICAgKCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuICAgICAgICAgICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAhZG9jdW1lbnRJc0hUTUwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgICFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbiAgICAgICAgICAgIHN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgICAgICAgICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuICAgICAgICAgICAgc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xuICAgICAgICAgICAgfSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG4gICAgICAgICAgICB9KSApIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWlzWE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG4gICAgICAgICAgICBpZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG4gICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuICAgICAgICAgICAgICAgIGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xuICAgICAgICAgICAgfSkgKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuICAgICAgICAgICAgaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbiAgICAgICAgICAgIH0pICkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNYTUwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwudmFsdWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBTaXp6bGU7XG5cbiAgICAgICAgfSkoIHdpbmRvdyApO1xuXG5cblxuICAgIGpRdWVyeS5maW5kID0gU2l6emxlO1xuICAgIGpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxuICAgIGpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbiAgICBqUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbiAgICBqUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xuICAgIGpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbiAgICBqUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG4gICAgalF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxuICAgIHZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgIHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuICAgICAgICB3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcbiAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfTtcblxuXG4gICAgdmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gW107XG5cbiAgICAgICAgZm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcbiAgICAgICAgICAgIGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCggbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfTtcblxuXG4gICAgdmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG4gICAgZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB9O1xuICAgIHZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbiAgICBmdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcbiAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZSBlbGVtZW50XG4gICAgICAgIGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuICAgICAgICBpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuICAgICAgICByZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuICAgICAgICB2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cbiAgICAgICAgaWYgKCBub3QgKSB7XG4gICAgICAgICAgICBleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuICAgICAgICB9ICkgKTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICB2YXIgaSwgcmV0LFxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG4gICAgICAgIH0sXG4gICAgICAgIG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiAhIXdpbm5vdyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuICAgICAgICAgICAgICAgIC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cbiAgICAgICAgICAgICAgICB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBzZWxlY3RvciApIDpcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgfHwgW10sXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG4gICAgdmFyIHJvb3RqUXVlcnksXG5cbiAgICAgICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcbiAgICAgICAgLy8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuICAgICAgICAvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcbiAgICAgICAgLy8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuICAgICAgICBycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cbiAgICAgICAgaW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuICAgICAgICAgICAgdmFyIG1hdGNoLCBlbGVtO1xuXG4gICAgICAgICAgICAvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcbiAgICAgICAgICAgIGlmICggIXNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcbiAgICAgICAgICAgIC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcbiAgICAgICAgICAgIHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBIVE1MIHN0cmluZ3NcbiAgICAgICAgICAgIGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsgMSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKCNpZClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbIDAgXSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKERPTUVsZW1lbnQpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzWyAwIF0gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICByb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yKCBqUXVlcnkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG4gICAgICAgIH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbiAgICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxuICAgIHJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxuICAgIHZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuICAgICAgICAvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuICAgICAgICBndWFyYW50ZWVkVW5pcXVlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRydWUsXG4gICAgICAgICAgICBjb250ZW50czogdHJ1ZSxcbiAgICAgICAgICAgIG5leHQ6IHRydWUsXG4gICAgICAgICAgICBwcmV2OiB0cnVlXG4gICAgICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcbiAgICAgICAgICAgICAgICBsID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcbiAgICAgICAgICAgIHZhciBjdXIsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG4gICAgICAgICAgICAvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG4gICAgICAgICAgICBpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcbiAgICAgICAgaW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAgICAgICAvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuICAgICAgICAgICAgaWYgKCAhZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluZGV4IGluIHNlbGVjdG9yXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuICAgICAgICAgICAgICAgIGpRdWVyeS51bmlxdWVTb3J0KFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuICAgICAgICAgICAgICAgIHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBmdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcbiAgICAgICAgd2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKCB7XG4gICAgICAgIHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuICAgICAgICAgICAgcmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbS5jb250ZW50RG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuICAgICAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG4gICAgICAgICAgICBpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVudGlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICAgICAgICAgICAgICAgIGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuICAgICAgICAgICAgICAgIGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcbiAgICAgICAgfTtcbiAgICB9ICk7XG4gICAgdmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbiAgICBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuICAgICAgICAgICAgb2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuICAgICAgICB9ICk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbiAgICBqUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cbiAgICAgICAgLy8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuICAgICAgICAvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG4gICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuICAgICAgICB2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuICAgICAgICAgICAgZmlyaW5nLFxuXG4gICAgICAgICAgICAvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuICAgICAgICAgICAgbWVtb3J5LFxuXG4gICAgICAgICAgICAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuICAgICAgICAgICAgZmlyZWQsXG5cbiAgICAgICAgICAgIC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcbiAgICAgICAgICAgIGxvY2tlZCxcblxuICAgICAgICAgICAgLy8gQWN0dWFsIGNhbGxiYWNrIGxpc3RcbiAgICAgICAgICAgIGxpc3QgPSBbXSxcblxuICAgICAgICAgICAgLy8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcbiAgICAgICAgICAgIHF1ZXVlID0gW10sXG5cbiAgICAgICAgICAgIC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuICAgICAgICAgICAgZmlyaW5nSW5kZXggPSAtMSxcblxuICAgICAgICAgICAgLy8gRmlyZSBjYWxsYmFja3NcbiAgICAgICAgICAgIGZpcmUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuICAgICAgICAgICAgICAgIGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuICAgICAgICAgICAgICAgIGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG4gICAgICAgICAgICAgICAgaWYgKCBsb2NrZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG1lbW9yeSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuICAgICAgICAgICAgc2VsZiA9IHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3QgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKCBhcmcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zcGVjdCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKCBhcmcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKSggYXJndW1lbnRzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG4gICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbiggZm4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbiA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG4gICAgICAgICAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFsaXN0O1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIC5maXJlXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcbiAgICAgICAgICAgICAgICAvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG4gICAgICAgICAgICAgICAgbG9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IG1lbW9yeSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFsb2NrZWQ7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWxvY2tlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWZpcmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG4gICAgICAgICAgICAgICAgZmlyZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFmaXJlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG4gICAgICAgIHZhciBtZXRob2Q7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuICAgICAgICAgICAgICAgIC8vIE90aGVyIHRoZW5hYmxlc1xuICAgICAgICAgICAgfSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcbiAgICAgICAgICAgICAgICAvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG4gICAgICAgICAgICAgICAgLy8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcbiAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuICAgICAgICAgICAgLy8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuICAgICAgICAgICAgLy8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cbiAgICAgICAgfSBjYXRjaCAoIHZhbHVlICkge1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG4gICAgICAgICAgICAvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG4gICAgICAgICAgICByZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG5cbiAgICAgICAgRGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuICAgICAgICAgICAgdmFyIHR1cGxlcyA9IFtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG4gICAgICAgICAgICAgICAgICAgIFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgWyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuICAgICAgICAgICAgICAgICAgICBbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBcInBlbmRpbmdcIixcbiAgICAgICAgICAgICAgICBwcm9taXNlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgICAgICAgICBwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC5wcm9taXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5zID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhEZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCwgdGhlbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiA9IHJldHVybmVkICYmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQudGhlbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNwZWNpYWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyByZXR1cm5lZCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgdmFsdWUocylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MgPSBzcGVjaWFsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWdodFRocm93IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZ2h0VGhyb3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbIGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkZXB0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLm5vdGlmeVdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25GdWxmaWxsZWQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElkZW50aXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlamVjdGVkIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaHJvd2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB7fTtcblxuICAgICAgICAgICAgLy8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuICAgICAgICAgICAgICAgIHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKCBzdGF0ZVN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuICAgICAgICAgICAgICAgIC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgICAgICAgICBsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuICAgICAgICAgICAgcHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG4gICAgICAgICAgICAvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG4gICAgICAgICAgICBpZiAoIGZ1bmMgKSB7XG4gICAgICAgICAgICAgICAgZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWxsIGRvbmUhXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGVmZXJyZWQgaGVscGVyXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcbiAgICAgICAgICAgIHZhclxuXG4gICAgICAgICAgICAgICAgLy8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuICAgICAgICAgICAgICAgIC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGkgPSByZW1haW5pbmcsXG5cbiAgICAgICAgICAgICAgICAvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFzdGVyIERlZmVycmVkXG4gICAgICAgICAgICAgICAgbWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cbiAgICAgICAgICAgICAgICAvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG4gICAgICAgICAgICBpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuICAgICAgICAgICAgICAgIGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgIXJlbWFpbmluZyApO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuICAgICAgICAgICAgICAgIGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXN0ZXIudGhlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcbiAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgIGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG4gICAgdmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbiAgICBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuICAgICAgICAvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuICAgICAgICBpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cblxuICAgIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gKTtcbiAgICB9O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbiAgICB2YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbiAgICBqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cbiAgICAgICAgcmVhZHlMaXN0XG4gICAgICAgICAgICAudGhlbiggZm4gKVxuXG4gICAgICAgICAgICAvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuICAgICAgICAgICAgLy8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyByZWdpc3RyYXRpb24uXG4gICAgICAgICAgICAuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoIHtcblxuICAgICAgICAvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuICAgICAgICBpc1JlYWR5OiBmYWxzZSxcblxuICAgICAgICAvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG4gICAgICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG4gICAgICAgIHJlYWR5V2FpdDogMSxcblxuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICAgIHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuICAgICAgICAgICAgLy8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuICAgICAgICAgICAgaWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgICAgIGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcbiAgICAgICAgICAgIGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbiAgICAgICAgalF1ZXJ5LnJlYWR5KCk7XG4gICAgfVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbiAgICBpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuICAgICAgICAoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuICAgICAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuICAgIH1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbiAgICB2YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBidWxrID0ga2V5ID09IG51bGw7XG5cbiAgICAgICAgLy8gU2V0cyBtYW55IHZhbHVlc1xuICAgICAgICBpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICBjaGFpbmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICggaSBpbiBrZXkgKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHMgb25lIHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBjaGFpbmFibGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggYnVsayApIHtcblxuICAgICAgICAgICAgICAgIC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuICAgICAgICAgICAgICAgIGlmICggcmF3ICkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWxrID0gZm47XG4gICAgICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZm4gKSB7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggY2hhaW5hYmxlICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0c1xuICAgICAgICBpZiAoIGJ1bGsgKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbiAgICB9O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuICAgIHZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuICAgICAgICByZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuICAgIGZ1bmN0aW9uIGZjYW1lbENhc2UoIGFsbCwgbGV0dGVyICkge1xuICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG4gICAgZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuICAgIH1cbiAgICB2YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuICAgICAgICAvLyBBY2NlcHRzIG9ubHk6XG4gICAgICAgIC8vICAtIE5vZGVcbiAgICAgICAgLy8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuICAgICAgICAvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuICAgICAgICAvLyAgLSBPYmplY3RcbiAgICAgICAgLy8gICAgLSBBbnlcbiAgICAgICAgcmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBEYXRhKCkge1xuICAgICAgICB0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG4gICAgfVxuXG4gICAgRGF0YS51aWQgPSAxO1xuXG4gICAgRGF0YS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cbiAgICAgICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuICAgICAgICAgICAgaWYgKCAhdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgICAgICAgICAgaWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHBsYWluIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvd25lci5ub2RlVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIHByb3AsXG4gICAgICAgICAgICAgICAgY2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG4gICAgICAgICAgICAvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgZm9yICggcHJvcCBpbiBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuICAgICAgICAgICAgICAgIG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcbiAgICAgICAgfSxcbiAgICAgICAgYWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cbiAgICAgICAgICAgIC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG4gICAgICAgICAgICAvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuICAgICAgICAgICAgLy8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gICAyLiBBIGtleSBhbmQgdmFsdWVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuICAgICAgICAgICAgLy8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuICAgICAgICAgICAgaWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG4gICAgICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleSBpbiBjYWNoZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBbIGtleSBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0ga2V5Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcbiAgICAgICAgICAgIGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG4gICAgICAgICAgICAgICAgLy8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcbiAgICAgICAgICAgICAgICBpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgICAgICAgICBvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxuICAgIHZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbiAgICB2YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuICAgICAgICBybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbiAgICBmdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuICAgICAgICBpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG4gICAgICAgIGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuICAgICAgICAgICAgcmV0dXJuICtkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG4gICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgIC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcbiAgICAgICAgLy8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG4gICAgICAgIGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHt9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICBkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcbiAgICAgICAgICAgIGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG4gICAgICAgIC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuICAgICAgICBfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIGksIG5hbWUsIGRhdGEsXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIDAgXSxcbiAgICAgICAgICAgICAgICBhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAvLyBHZXRzIGFsbCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gYXR0cnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhdHRyc1sgaSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGE7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgIC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBkYXRhLi4uXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG4gICAgICAgICAgICAgICAgICAgIGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHZhciBxdWV1ZTtcblxuICAgICAgICAgICAgaWYgKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG4gICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuICAgICAgICAgICAgICAgIC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcXVldWUgfHwgW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuICAgICAgICAgICAgICAgIHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKSxcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuICAgICAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG4gICAgICAgICAgICBpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcbiAgICAgICAgICAgICAgICBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGgtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBmbiApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcbiAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuICAgICAgICBfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG4gICAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHZhciBzZXR0ZXIgPSAyO1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImZ4XCI7XG4gICAgICAgICAgICAgICAgc2V0dGVyLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpcyA6XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcbiAgICAgICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG4gICAgICAgIHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG4gICAgICAgICAgICB2YXIgdG1wLFxuICAgICAgICAgICAgICAgIGNvdW50ID0gMSxcbiAgICAgICAgICAgICAgICBkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICEoIC0tY291bnQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIG9iaiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG4gICAgdmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG4gICAgdmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbiAgICB2YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuICAgIHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuICAgIC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuICAgIC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuICAgIC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcbiAgICAvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cbiAgICBpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcbiAgICAgICAgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcbiAgICAgICAgICAgICAgICBlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cbiAgICAgICAgLy8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuICAgICAgICBlbGVtID0gZWwgfHwgZWxlbTtcblxuICAgICAgICAvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuICAgICAgICByZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcbiAgICAgICAgICAgIC8vIGluIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgIGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG4gICAgICAgICAgICBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcbiAgICB9O1xuXG4gICAgdmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG4gICAgICAgIHZhciByZXQsIG5hbWUsXG4gICAgICAgICAgICBvbGQgPSB7fTtcblxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgICAgICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgb2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICBlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG4gICAgICAgIC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG4gICAgICAgIHZhciBhZGp1c3RlZCwgc2NhbGUsXG4gICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMjAsXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0d2Vlbi5jdXIoKTtcbiAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuICAgICAgICAgICAgdW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG4gICAgICAgICAgICAvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuICAgICAgICAgICAgaW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcbiAgICAgICAgICAgICAgICAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuICAgICAgICAgICAgICAgIHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cbiAgICAgICAgaWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG4gICAgICAgICAgICAvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG4gICAgICAgICAgICBpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cbiAgICAgICAgICAgIC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcbiAgICAgICAgICAgIHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuICAgICAgICAgICAgLy8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG4gICAgICAgICAgICB3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcbiAgICAgICAgICAgICAgICBpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG4gICAgICAgICAgICB2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdmFsdWVQYXJ0cyApIHtcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG4gICAgICAgICAgICAvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cbiAgICAgICAgICAgICAgICBpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuICAgICAgICAgICAgICAgICt2YWx1ZVBhcnRzWyAyIF07XG4gICAgICAgICAgICBpZiAoIHR3ZWVuICkge1xuICAgICAgICAgICAgICAgIHR3ZWVuLnVuaXQgPSB1bml0O1xuICAgICAgICAgICAgICAgIHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRqdXN0ZWQ7XG4gICAgfVxuXG5cbiAgICB2YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuICAgICAgICB2YXIgdGVtcCxcbiAgICAgICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcbiAgICAgICAgICAgIGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuICAgICAgICBpZiAoIGRpc3BsYXkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcbiAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cbiAgICAgICAgdGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cbiAgICAgICAgaWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcbiAgICAgICAgICAgIGRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG4gICAgICAgIHJldHVybiBkaXNwbGF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcbiAgICAgICAgdmFyIGRpc3BsYXksIGVsZW0sXG4gICAgICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2VcbiAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcbiAgICAgICAgICAgIGlmICggIWVsZW0uc3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBpZiAoIHNob3cgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG4gICAgICAgICAgICAgICAgLy8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuICAgICAgICAgICAgICAgIGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuICAgICAgICBmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgaWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG4gICAgdmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG4gICAgdmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxuICAgIHZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbiAgICB2YXIgd3JhcE1hcCA9IHtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICBvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuICAgICAgICAvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuICAgICAgICAvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG4gICAgICAgIC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cbiAgICAgICAgdGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuICAgICAgICBjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuICAgICAgICB0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG4gICAgICAgIHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuICAgICAgICBfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbiAgICB9O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgIHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxuICAgIHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG4gICAgd3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuICAgIGZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAgICAgLy8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgICAgICByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICAgICAgcmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbiAgICBmdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgZGF0YVByaXYuc2V0KFxuICAgICAgICAgICAgICAgIGVsZW1zWyBpIF0sXG4gICAgICAgICAgICAgICAgXCJnbG9iYWxFdmFsXCIsXG4gICAgICAgICAgICAgICAgIXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgdmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcbiAgICAgICAgdmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcbiAgICAgICAgICAgIGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICBub2RlcyA9IFtdLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBub2RlcyBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGogPSB3cmFwWyAwIF07XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggai0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG4gICAgICAgICAgICAgICAgICAgIHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuICAgICAgICBmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cbiAgICAgICAgICAgIC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG4gICAgICAgICAgICBpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlnbm9yZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZWQucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byBmcmFnbWVudFxuICAgICAgICAgICAgdG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgICAgIGlmICggYXR0YWNoZWQgKSB7XG4gICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbCggdG1wICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcbiAgICAgICAgICAgIGlmICggc2NyaXB0cyApIHtcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfVxuXG5cbiAgICAoIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICBkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG4gICAgICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcbiAgICAgICAgLy8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcbiAgICAgICAgLy8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuICAgICAgICAvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuICAgICAgICAvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcbiAgICAgICAgc3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG4gICAgICAgIHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuICAgIH0gKSgpO1xuXG5cbiAgICB2YXJcbiAgICAgICAgcmtleUV2ZW50ID0gL15rZXkvLFxuICAgICAgICBybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcbiAgICAgICAgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbiAgICBmdW5jdGlvbiBleHBlY3RTeW5jKCBlbGVtLCB0eXBlICkge1xuICAgICAgICByZXR1cm4gKCBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICkgPT09ICggdHlwZSA9PT0gXCJmb2N1c1wiICk7XG4gICAgfVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG4gICAgZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgfSBjYXRjaCAoIGVyciApIHsgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG4gICAgICAgIHZhciBvcmlnRm4sIHR5cGU7XG5cbiAgICAgICAgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG4gICAgICAgIGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuICAgICAgICAgICAgICAgIG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIC8vICggdHlwZXMsIGZuIClcbiAgICAgICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgICAgICBkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG4gICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxuICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCAhZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb25lID09PSAxICkge1xuICAgICAgICAgICAgb3JpZ0ZuID0gZm47XG4gICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuICAgICAgICAgICAgICAgIGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG4gICAgICAgICAgICBmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcbiAgICAgICAgfSApO1xuICAgIH1cblxuICAgIC8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG4gICAgalF1ZXJ5LmV2ZW50ID0ge1xuXG4gICAgICAgIGdsb2JhbDoge30sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG4gICAgICAgICAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXG4gICAgICAgICAgICAgICAgc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG4gICAgICAgICAgICBpZiAoICFlbGVtRGF0YSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuICAgICAgICAgICAgaWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuICAgICAgICAgICAgaWYgKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAgICAgICBpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAgICAgaWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcbiAgICAgICAgICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuICAgICAgICAgICAgdHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuICAgICAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggdC0tICkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgaWYgKCAhdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcbiAgICAgICAgICAgICAgICB0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVPYmpJbiApO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICBpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsLmFkZCApIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuICAgICAgICAgICAgICAgIGlmICggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG4gICAgICAgICAgICB2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG4gICAgICAgICAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXG4gICAgICAgICAgICAgICAgc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG4gICAgICAgICAgICBpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcbiAgICAgICAgICAgIHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcbiAgICAgICAgICAgIHQgPSB0eXBlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIHQtLSApIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG4gICAgICAgICAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmICggIXR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG4gICAgICAgICAgICAgICAgdHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG4gICAgICAgICAgICAgICAgdG1wID0gdG1wWyAyIF0gJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgb3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcbiAgICAgICAgICAgICAgICAvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcbiAgICAgICAgICAgICAgICBpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcbiAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuICAgICAgICAgICAgLy8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG4gICAgICAgICAgICB2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcbiAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcbiAgICAgICAgICAgIGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG4gICAgICAgICAgICBpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBoYW5kbGVyc1xuICAgICAgICAgICAgaGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG4gICAgICAgICAgICAvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcbiAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG4gICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcbiAgICAgICAgICAgICAgICAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcbiAgICAgICAgICAgIGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcbiAgICAgICAgICAgIHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuICAgICAgICAgICAgICAgIGN1ciA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgLy8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuICAgICAgICAgICAgaWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTlcbiAgICAgICAgICAgICAgICAvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcbiAgICAgICAgICAgICAgICBjdXIubm9kZVR5cGUgJiZcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuICAgICAgICAgICAgICAgIC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEgb25seVxuICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0MylcbiAgICAgICAgICAgICAgICAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuICAgICAgICAgICAgICAgIGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG4gICAgICAgICAgICBjdXIgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlclF1ZXVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICAgICAgICAgICAgICBnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQgOlxuICAgICAgICAgICAgICAgIG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzcGVjaWFsOiB7XG4gICAgICAgICAgICBsb2FkOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG4gICAgICAgICAgICAgICAgbm9CdWJibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGljazoge1xuXG4gICAgICAgICAgICAgICAgLy8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcbiAgICAgICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIsIHJldHVyblRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuICAgICAgICAgICAgICAgICAgICAvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3NcbiAgICAgICAgICAgICAgICAvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcbiAgICAgICAgICAgICAgICBfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsaWNrICYmIG5vZGVOYW1lKCB0YXJnZXQsIFwiaW5wdXRcIiApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmVmb3JldW5sb2FkOiB7XG4gICAgICAgICAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCAyMCtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuICAgIGZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuICAgICAgICAvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuICAgICAgICBpZiAoICFleHBlY3RTeW5jICkge1xuICAgICAgICAgICAgaWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuICAgICAgICBkYXRhUHJpdi5zZXQoIGVsLCB0eXBlLCBmYWxzZSApO1xuICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xuICAgICAgICAgICAgbmFtZXNwYWNlOiBmYWxzZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm90QXN5bmMsIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuICAgICAgICAgICAgICAgIGlmICggKCBldmVudC5pc1RyaWdnZXIgJiAxICkgJiYgdGhpc1sgdHlwZSBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmVkIGRhdGEgc2hvdWxkIGJlIGZhbHNlIGluIHN1Y2ggY2FzZXMsIGJ1dCBtaWdodCBiZSBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGZyb20gYW4gYXN5bmMgbmF0aXZlIGhhbmRsZXIgKGdoLTQzNTApXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXNhdmVkLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RBc3luYyA9IGV4cGVjdFN5bmMoIHRoaXMsIHR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbIHR5cGUgXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNhdmVkICE9PSByZXN1bHQgfHwgbm90QXN5bmMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNhdmVkLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZWQuc2xpY2UoIDEgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH1cblxuICAgIGpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cbiAgICAgICAgLy8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG4gICAgICAgIGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuICAgICAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcbiAgICAgICAgaWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXZlbnQgb2JqZWN0XG4gICAgICAgIGlmICggc3JjICYmIHNyYy50eXBlICkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAgICAgICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAgICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcbiAgICAgICAgICAgIHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG4gICAgICAgICAgICBzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICByZXR1cm5UcnVlIDpcbiAgICAgICAgICAgICAgICByZXR1cm5GYWxzZTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG4gICAgICAgICAgICAvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cbiAgICAgICAgICAgICAgICBzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuICAgICAgICAgICAgICAgIHNyYy50YXJnZXQ7XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIEV2ZW50IHR5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICAgIGlmICggcHJvcHMgKSB7XG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICAgICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIE1hcmsgaXQgYXMgZml4ZWRcbiAgICAgICAgdGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG4gICAgfTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG4gICAgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgICAgICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgICAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICAgIGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xuICAgIGpRdWVyeS5lYWNoKCB7XG4gICAgICAgIGFsdEtleTogdHJ1ZSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXM6IHRydWUsXG4gICAgICAgIGN0cmxLZXk6IHRydWUsXG4gICAgICAgIGRldGFpbDogdHJ1ZSxcbiAgICAgICAgZXZlbnRQaGFzZTogdHJ1ZSxcbiAgICAgICAgbWV0YUtleTogdHJ1ZSxcbiAgICAgICAgcGFnZVg6IHRydWUsXG4gICAgICAgIHBhZ2VZOiB0cnVlLFxuICAgICAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICAgICAgdmlldzogdHJ1ZSxcbiAgICAgICAgXCJjaGFyXCI6IHRydWUsXG4gICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgIGNoYXJDb2RlOiB0cnVlLFxuICAgICAgICBrZXk6IHRydWUsXG4gICAgICAgIGtleUNvZGU6IHRydWUsXG4gICAgICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgYnV0dG9uczogdHJ1ZSxcbiAgICAgICAgY2xpZW50WDogdHJ1ZSxcbiAgICAgICAgY2xpZW50WTogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0WDogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0WTogdHJ1ZSxcbiAgICAgICAgcG9pbnRlcklkOiB0cnVlLFxuICAgICAgICBwb2ludGVyVHlwZTogdHJ1ZSxcbiAgICAgICAgc2NyZWVuWDogdHJ1ZSxcbiAgICAgICAgc2NyZWVuWTogdHJ1ZSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlczogdHJ1ZSxcbiAgICAgICAgdG9FbGVtZW50OiB0cnVlLFxuICAgICAgICB0b3VjaGVzOiB0cnVlLFxuXG4gICAgICAgIHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG4gICAgICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcbiAgICAgICAgICAgIGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG4gICAgICAgICAgICBpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBidXR0b24gJiAxICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGJ1dHRvbiAmIDIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggYnV0dG9uICYgNCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC53aGljaDtcbiAgICAgICAgfVxuICAgIH0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbiAgICBqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG4gICAgICAgICAgICAvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgLy8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG4gICAgICAgICAgICAgICAgLy8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcbiAgICAgICAgICAgICAgICBsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuICAgICAgICAgICAgICAgIGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuICAgICAgICB9O1xuICAgIH0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbiAgICBqUXVlcnkuZWFjaCgge1xuICAgICAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICAgICAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG4gICAgICAgIHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuICAgICAgICBwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG4gICAgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcbiAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogZml4LFxuICAgICAgICAgICAgYmluZFR5cGU6IGZpeCxcblxuICAgICAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuICAgICAgICAgICAgICAgIC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICAgICAgLy8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcbiAgICAgICAgICAgICAgICBpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cbiAgICAgICAgb246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVPYmosIHR5cGU7XG4gICAgICAgICAgICBpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuICAgICAgICAgICAgICAgIC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm5hbWVzcGFjZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm9yaWdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcbiAgICAgICAgICAgICAgICBmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4gICAgdmFyXG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuICAgICAgICByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuICAgICAgICAvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuICAgICAgICAvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcbiAgICAgICAgcmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuICAgICAgICByY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuICAgIGZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcbiAgICAgICAgICAgIG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuICAgIGZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG4gICAgICAgIGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcbiAgICAgICAgaWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuICAgICAgICAgICAgZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG4gICAgICAgIHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG4gICAgICAgIGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG4gICAgICAgIGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG4gICAgICAgICAgICBwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG4gICAgICAgICAgICBwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcbiAgICAgICAgICAgIGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuICAgICAgICAgICAgaWYgKCBldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcbiAgICAgICAgICAgICAgICBwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIENvcHkgdXNlciBkYXRhXG4gICAgICAgIGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG4gICAgICAgICAgICB1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG4gICAgICAgICAgICB1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG4gICAgICAgICAgICBkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuICAgIGZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG4gICAgICAgIHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cbiAgICAgICAgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG4gICAgICAgICAgICBkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuICAgICAgICAgICAgLy8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcbiAgICAgICAgfSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuICAgICAgICAgICAgZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICAgICAgYXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuICAgICAgICB2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGlOb0Nsb25lID0gbCAtIDEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbIDAgXSxcbiAgICAgICAgICAgIHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cbiAgICAgICAgLy8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG4gICAgICAgIGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG4gICAgICAgICAgICAoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBsICkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcbiAgICAgICAgICAgIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgaWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZpcnN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG4gICAgICAgICAgICAgICAgaGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuICAgICAgICAgICAgICAgIC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSBpTm9DbG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNTY3JpcHRzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggaGFzU2NyaXB0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWVuYWJsZSBzY3JpcHRzXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcbiAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICBub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICBmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgIGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuICAgICAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuICAgICAgICAgICAgdmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG4gICAgICAgICAgICAgICAgY2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuICAgICAgICAgICAgICAgIGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuICAgICAgICAgICAgLy8gRml4IElFIGNsb25pbmcgaXNzdWVzXG4gICAgICAgICAgICBpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG4gICAgICAgICAgICAgICAgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgZml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG4gICAgICAgICAgICBpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG4gICAgICAgICAgICBkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG4gICAgICAgICAgICBpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgIHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgZm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhLmV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkudGV4dCggdGhpcyApIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJlZm9yZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuICAgICAgICAgICAgZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcbiAgICAgICAgICAgIGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHt9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlnbm9yZWQgPSBbXTtcblxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuICAgICAgICAgICAgfSwgaWdub3JlZCApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmVhY2goIHtcbiAgICAgICAgYXBwZW5kVG86IFwiYXBwZW5kXCIsXG4gICAgICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG4gICAgICAgIGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcbiAgICAgICAgaW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcbiAgICAgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG4gICAgfSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHZhciBlbGVtcyxcbiAgICAgICAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG4gICAgICAgICAgICAgICAgbGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgLy8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcbiAgICAgICAgfTtcbiAgICB9ICk7XG4gICAgdmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG4gICAgdmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcbiAgICAgICAgLy8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG4gICAgICAgIC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuICAgICAgICB2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgICAgICBpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcbiAgICAgICAgICAgIHZpZXcgPSB3aW5kb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG4gICAgfTtcblxuICAgIHZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiAgICAoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuICAgICAgICAvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuICAgICAgICAgICAgaWYgKCAhZGl2ICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG4gICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG4gICAgICAgICAgICAgICAgXCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcbiAgICAgICAgICAgICAgICBcIndpZHRoOjYwJTt0b3A6MSVcIjtcbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG4gICAgICAgICAgICB2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcbiAgICAgICAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG4gICAgICAgICAgICAvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3RcbiAgICAgICAgICAgIGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG4gICAgICAgICAgICBwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG4gICAgICAgICAgICAvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG4gICAgICAgICAgICBib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgb25seVxuICAgICAgICAgICAgLy8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NjRcbiAgICAgICAgICAgIC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuICAgICAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgc2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcblxuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuICAgICAgICAgICAgLy8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuICAgICAgICAgICAgLy8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuICAgICAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG4gICAgICAgICAgICByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cbiAgICAgICAgLy8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcbiAgICAgICAgaWYgKCAhZGl2LnN0eWxlICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG4gICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcbiAgICAgICAgZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcbiAgICAgICAgc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuICAgICAgICBqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG4gICAgICAgICAgICBib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH0gKSgpO1xuXG5cbiAgICBmdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuICAgICAgICB2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuICAgICAgICAgICAgLy8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuICAgICAgICAgICAgLy8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuICAgICAgICAgICAgLy8gb24gZGV0YWNoZWQgZWxlbWVudHNcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICBjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG4gICAgICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcbiAgICAgICAgLy8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG4gICAgICAgIC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgcmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cbiAgICAgICAgICAgIGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcbiAgICAgICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuICAgICAgICAgICAgLy8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICAgICAgICBpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgICAgICAgICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAgICAgLy8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cbiAgICAgICAgICAgIHJldCArIFwiXCIgOlxuICAgICAgICAgICAgcmV0O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG4gICAgICAgIC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5nZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIHZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG4gICAgICAgIGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG4gICAgICAgIHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuICAgICAgICAvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG4gICAgICAgIHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG4gICAgICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgbmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuICAgICAgICAgICAgaWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG4gICAgZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcbiAgICAgICAgdmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuICAgICAgICBpZiAoIGZpbmFsICkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG4gICAgfVxuXG5cbiAgICB2YXJcblxuICAgICAgICAvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG4gICAgICAgIC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuICAgICAgICAvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcbiAgICAgICAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuICAgICAgICByY3VzdG9tUHJvcCA9IC9eLS0vLFxuICAgICAgICBjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcbiAgICAgICAgY3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogXCIwXCIsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiBcIjQwMFwiXG4gICAgICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG4gICAgICAgIC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgICAgICAgLy8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG4gICAgICAgIHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuICAgICAgICByZXR1cm4gbWF0Y2hlcyA/XG5cbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG4gICAgICAgICAgICBNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcbiAgICAgICAgICAgIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuICAgICAgICB2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG4gICAgICAgICAgICBleHRyYSA9IDAsXG4gICAgICAgICAgICBkZWx0YSA9IDA7XG5cbiAgICAgICAgLy8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cbiAgICAgICAgICAgIC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuICAgICAgICAgICAgaWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG4gICAgICAgICAgICBpZiAoICFpc0JvcmRlckJveCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuICAgICAgICAgICAgICAgIC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcbiAgICAgICAgICAgICAgICBpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcbiAgICAgICAgaWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuICAgICAgICAgICAgLy8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuICAgICAgICAgICAgLy8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuICAgICAgICAgICAgZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICBlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuICAgICAgICAgICAgICAgIGNvbXB1dGVkVmFsIC1cbiAgICAgICAgICAgICAgICBkZWx0YSAtXG4gICAgICAgICAgICAgICAgZXh0cmEgLVxuICAgICAgICAgICAgICAgIDAuNVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcbiAgICAgICAgICAgICAgICAvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG4gICAgICAgICAgICApICkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcbiAgICAgICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cbiAgICAgICAgICAgIC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuICAgICAgICAgICAgYm94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcbiAgICAgICAgICAgIGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuICAgICAgICAgICAgdmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuICAgICAgICAgICAgb2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG4gICAgICAgIC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgICBpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcbiAgICAgICAgICAgIGlmICggIWV4dHJhICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSBcImF1dG9cIjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG4gICAgICAgIC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG4gICAgICAgIC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuICAgICAgICAvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG4gICAgICAgIC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuICAgICAgICAvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcbiAgICAgICAgaWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcbiAgICAgICAgICAgIHZhbCA9PT0gXCJhdXRvXCIgfHxcbiAgICAgICAgICAgICFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcbiAgICAgICAgICAgIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuICAgICAgICAgICAgLy8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuICAgICAgICAgICAgLy8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuICAgICAgICAgICAgLy8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuICAgICAgICAgICAgdmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcbiAgICAgICAgICAgIGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG4gICAgICAgIC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcbiAgICAgICAgcmV0dXJuICggdmFsICtcbiAgICAgICAgICAgIGJveE1vZGVsQWRqdXN0bWVudChcbiAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICBleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG4gICAgICAgICAgICAgICAgdmFsdWVJc0JvcmRlckJveCxcbiAgICAgICAgICAgICAgICBzdHlsZXMsXG5cbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuICAgICAgICAgICAgICAgIHZhbFxuICAgICAgICAgICAgKVxuICAgICAgICApICsgXCJweFwiO1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoIHtcblxuICAgICAgICAvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG4gICAgICAgIGNzc0hvb2tzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG4gICAgICAgIGNzc051bWJlcjoge1xuICAgICAgICAgICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmbGV4R3Jvd1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJmbGV4U2hyaW5rXCI6IHRydWUsXG4gICAgICAgICAgICBcImZvbnRXZWlnaHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZ3JpZEFyZWFcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuICAgICAgICAgICAgXCJncmlkQ29sdW1uRW5kXCI6IHRydWUsXG4gICAgICAgICAgICBcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJncmlkUm93XCI6IHRydWUsXG4gICAgICAgICAgICBcImdyaWRSb3dFbmRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG4gICAgICAgICAgICBcImxpbmVIZWlnaHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcmRlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcnBoYW5zXCI6IHRydWUsXG4gICAgICAgICAgICBcIndpZG93c1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ6SW5kZXhcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiem9vbVwiOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuICAgICAgICAvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG4gICAgICAgIGNzc1Byb3BzOiB7fSxcblxuICAgICAgICAvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuICAgICAgICBzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuICAgICAgICAgICAgLy8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuICAgICAgICAgICAgdmFyIHJldCwgdHlwZSwgaG9va3MsXG4gICAgICAgICAgICAgICAgb3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcbiAgICAgICAgICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAgICAgICAvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cbiAgICAgICAgICAgIGlmICggIWlzQ3VzdG9tUHJvcCApIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcbiAgICAgICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZXMgYnVnICM5MjM3XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcbiAgICAgICAgICAgICAgICAvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG4gICAgICAgICAgICAgICAgICAgICggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzQ3VzdG9tUHJvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG4gICAgICAgICAgICB2YXIgdmFsLCBudW0sIGhvb2tzLFxuICAgICAgICAgICAgICAgIG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG4gICAgICAgICAgICAgICAgaXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAgICAgICAvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG4gICAgICAgICAgICBpZiAoICFpc0N1c3RvbVByb3AgKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG4gICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcbiAgICAgICAgICAgIGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG4gICAgICAgICAgICBpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG4gICAgICAgICAgICBpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuICAgICAgICAgICAgICAgIG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xuICAgICAgICBqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuICAgICAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDgrXG4gICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG4gICAgICAgICAgICAgICAgICAgIGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcbiAgICAgICAgICAgICAgICAgICAgaXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0ID0gZXh0cmEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94TW9kZWxBZGp1c3RtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQm9yZGVyQm94LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcbiAgICAgICAgICAgICAgICBpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG4gICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cbiAgICAgICAgICAgICAgICAgICAgc3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgICAgICAgKSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbiAgICBqUXVlcnkuZWFjaCgge1xuICAgICAgICBtYXJnaW46IFwiXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiXCIsXG4gICAgICAgIGJvcmRlcjogXCJXaWR0aFwiXG4gICAgfSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuICAgICAgICBqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuICAgICAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA9IHt9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgNDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuICAgICAgICAgICAgalF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgY3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcywgbGVuLFxuICAgICAgICAgICAgICAgICAgICBtYXAgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IG5hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgICAgIH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cbiAgICBmdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG4gICAgfVxuICAgIGpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG4gICAgVHdlZW4ucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogVHdlZW4sXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICAgICAgICB0aGlzLnByb3AgPSBwcm9wO1xuICAgICAgICAgICAgdGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuICAgICAgICB9LFxuICAgICAgICBjdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuICAgICAgICAgICAgcmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG4gICAgICAgICAgICAgICAgaG9va3MuZ2V0KCB0aGlzICkgOlxuICAgICAgICAgICAgICAgIFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcbiAgICAgICAgICAgIHZhciBlYXNlZCxcbiAgICAgICAgICAgICAgICBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuICAgICAgICAgICAgICAgIGhvb2tzLnNldCggdGhpcyApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cbiAgICBUd2Vlbi5wcm9wSG9va3MgPSB7XG4gICAgICAgIF9kZWZhdWx0OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcbiAgICAgICAgICAgICAgICAvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuICAgICAgICAgICAgICAgIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG4gICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cbiAgICAgICAgICAgICAgICAvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcbiAgICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuICAgICAgICAgICAgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LmVhc2luZyA9IHtcbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbiggcCApIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICBzd2luZzogZnVuY3Rpb24oIHAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuICAgICAgICB9LFxuICAgICAgICBfZGVmYXVsdDogXCJzd2luZ1wiXG4gICAgfTtcblxuICAgIGpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxuICAgIGpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbiAgICB2YXJcbiAgICAgICAgZnhOb3csIGluUHJvZ3Jlc3MsXG4gICAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuICAgICAgICBycnVuID0gL3F1ZXVlSG9va3MkLztcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuICAgICAgICBpZiAoIGluUHJvZ3Jlc3MgKSB7XG4gICAgICAgICAgICBpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqUXVlcnkuZngudGljaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG4gICAgZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ4Tm93ID0gdW5kZWZpbmVkO1xuICAgICAgICB9ICk7XG4gICAgICAgIHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xuICAgIH1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbiAgICBmdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuICAgICAgICB2YXIgd2hpY2gsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuICAgICAgICAvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG4gICAgICAgIC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG4gICAgICAgIGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuICAgICAgICBmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG4gICAgICAgICAgICB3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuICAgICAgICAgICAgYXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGluY2x1ZGVXaWR0aCApIHtcbiAgICAgICAgICAgIGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG4gICAgICAgIHZhciB0d2VlbixcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgaWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG4gICAgICAgIHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcbiAgICAgICAgICAgIGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG4gICAgICAgICAgICBhbmltID0gdGhpcyxcbiAgICAgICAgICAgIG9yaWcgPSB7fSxcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZSxcbiAgICAgICAgICAgIGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG4gICAgICAgICAgICBkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG4gICAgICAgIC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuICAgICAgICBpZiAoICFvcHRzLnF1ZXVlICkge1xuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuICAgICAgICAgICAgaWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIGhvb2tzLnVucXVldWVkID0gMDtcbiAgICAgICAgICAgICAgICBvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcbiAgICAgICAgICAgICAgICBob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWhvb2tzLnVucXVldWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvb2tzLnVucXVldWVkKys7XG5cbiAgICAgICAgICAgIGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG4gICAgICAgICAgICAgICAgYW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBob29rcy51bnF1ZXVlZC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuICAgICAgICBmb3IgKCBwcm9wIGluIHByb3BzICkge1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuICAgICAgICAgICAgaWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuICAgICAgICBwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG4gICAgICAgIGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG4gICAgICAgIGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuICAgICAgICAgICAgLy8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG4gICAgICAgICAgICAvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcbiAgICAgICAgICAgIC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG4gICAgICAgICAgICBvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuICAgICAgICAgICAgLy8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG4gICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG4gICAgICAgICAgICBpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcbiAgICAgICAgICAgIGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCByZXN0b3JlRGlzcGxheSApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICBzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuICAgICAgICAgICAgICAgICAgICBzaG93SGlkZSggWyBlbGVtIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuICAgICAgICAgICAgaWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFwcm9wVHdlZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvcHRzLm92ZXJmbG93ICkge1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgYW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICAgICAgcHJvcFR3ZWVuID0gZmFsc2U7XG4gICAgICAgIGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuICAgICAgICAgICAgLy8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICggIXByb3BUd2VlbiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGFTaG93ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG4gICAgICAgICAgICAgICAgaWYgKCB0b2dnbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cbiAgICAgICAgICAgICAgICBpZiAoIGhpZGRlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cbiAgICAgICAgICAgICAgICBhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWhpZGRlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dIaWRlKCBbIGVsZW0gXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQZXItcHJvcGVydHkgc2V0dXBcbiAgICAgICAgICAgIHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuICAgICAgICAgICAgaWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG4gICAgICAgICAgICAgICAgZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoIGhpZGRlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFR3ZWVuLnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcbiAgICAgICAgdmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuICAgICAgICAvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3NcbiAgICAgICAgZm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuICAgICAgICAgICAgZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuICAgICAgICAgICAgICAgIHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbIGluZGV4IF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cbiAgICAgICAgICAgICAgICAvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG4gICAgICAgICAgICAgICAgLy8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuICAgICAgICAgICAgICAgIGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgc3RvcHBlZCxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aWNrLmVsZW07XG4gICAgICAgICAgICB9ICksXG4gICAgICAgICAgICB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzdG9wcGVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5NylcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gMSAtIHRlbXAsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuICAgICAgICAgICAgICAgIGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgIGlmICggIWxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuICAgICAgICAgICAgICAgIGVsZW06IGVsZW0sXG4gICAgICAgICAgICAgICAgcHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG4gICAgICAgICAgICAgICAgb3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyApLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR3ZWVuczogW10sXG4gICAgICAgICAgICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RvcHBlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICggZ290b0VuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApLFxuICAgICAgICAgICAgcHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cbiAgICAgICAgcHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgcmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcbiAgICAgICAgICAgIGlmICggcmVzdWx0ICkge1xuICAgICAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgalF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG4gICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG4gICAgICAgIGFuaW1hdGlvblxuICAgICAgICAgICAgLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG4gICAgICAgICAgICAuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuICAgICAgICAgICAgLmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuICAgICAgICAgICAgLmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cbiAgICAgICAgalF1ZXJ5LmZ4LnRpbWVyKFxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCggdGljaywge1xuICAgICAgICAgICAgICAgIGVsZW06IGVsZW0sXG4gICAgICAgICAgICAgICAgYW5pbTogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuICAgICAgICAgICAgfSApXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBqUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cbiAgICAgICAgdHdlZW5lcnM6IHtcbiAgICAgICAgICAgIFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgICAgIH0gXVxuICAgICAgICB9LFxuXG4gICAgICAgIHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwcm9wcztcbiAgICAgICAgICAgICAgICBwcm9wcyA9IFsgXCIqXCIgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvcCxcbiAgICAgICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wc1sgaW5kZXggXTtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cbiAgICAgICAgcHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG4gICAgICAgICAgICBpZiAoIHByZXBlbmQgKSB7XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcbiAgICAgICAgdmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuICAgICAgICAgICAgY29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuICAgICAgICAgICAgZHVyYXRpb246IHNwZWVkLFxuICAgICAgICAgICAgZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcbiAgICAgICAgaWYgKCBqUXVlcnkuZngub2ZmICkge1xuICAgICAgICAgICAgb3B0LmR1cmF0aW9uID0gMDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuICAgICAgICAgICAgICAgIGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcbiAgICAgICAgaWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG4gICAgICAgICAgICBvcHQucXVldWUgPSBcImZ4XCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBRdWV1ZWluZ1xuICAgICAgICBvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG4gICAgICAgIG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG4gICAgICAgICAgICAgICAgb3B0Lm9sZC5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggb3B0LnF1ZXVlICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3B0O1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuICAgICAgICAgICAgLy8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuICAgICAgICAgICAgICAgIC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG4gICAgICAgICAgICAgICAgb3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuICAgICAgICAgICAgICAgIGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbS5zdG9wKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cbiAgICAgICAgICAgIHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG4gICAgICAgICAgICB2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBzdG9wKCBnb3RvRW5kICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuICAgICAgICAgICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXF1ZXVlID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVxdWV1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG4gICAgICAgICAgICAgICAgLy8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cbiAgICAgICAgICAgICAgICBpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcbiAgICAgICAgICAgICAgICBkYXRhLmZpbmlzaCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3RcbiAgICAgICAgICAgICAgICBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG4gICAgICAgICAgICAgICAgZm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmZpbmlzaDtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcbiAgICAgICAgdmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG4gICAgICAgICAgICAgICAgY3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG4gICAgalF1ZXJ5LmVhY2goIHtcbiAgICAgICAgc2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcbiAgICAgICAgc2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG4gICAgICAgIHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuICAgICAgICBmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcbiAgICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuICAgICAgICBmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxuICAgIH0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcbiAgICAgICAgfTtcbiAgICB9ICk7XG5cbiAgICBqUXVlcnkudGltZXJzID0gW107XG4gICAgalF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpbWVyLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG4gICAgICAgIGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG4gICAgICAgICAgICAvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG4gICAgICAgICAgICBpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcbiAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIXRpbWVycy5sZW5ndGggKSB7XG4gICAgICAgICAgICBqUXVlcnkuZnguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ4Tm93ID0gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG4gICAgICAgIGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcbiAgICAgICAgalF1ZXJ5LmZ4LnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuICAgIGpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIGluUHJvZ3Jlc3MgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC5zcGVlZHMgPSB7XG4gICAgICAgIHNsb3c6IDYwMCxcbiAgICAgICAgZmFzdDogMjAwLFxuXG4gICAgICAgIC8vIERlZmF1bHQgc3BlZWRcbiAgICAgICAgX2RlZmF1bHQ6IDQwMFxuICAgIH07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbiAgICBqUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcbiAgICAgICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG4gICAgICAgICAgICBob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApO1xuICAgIH07XG5cblxuICAgICggZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuICAgICAgICAgICAgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuICAgICAgICAgICAgb3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuICAgICAgICBpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcbiAgICAgICAgc3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAgIC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG4gICAgICAgIHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAgIC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG4gICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG4gICAgICAgIGlucHV0LnZhbHVlID0gXCJ0XCI7XG4gICAgICAgIGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG4gICAgICAgIHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbiAgICB9ICkoKTtcblxuXG4gICAgdmFyIGJvb2xIb29rLFxuICAgICAgICBhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgYXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgYXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIHJldCwgaG9va3MsXG4gICAgICAgICAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG4gICAgICAgICAgICBpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgICAgICAgICAgLy8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuICAgICAgICAgICAgICAgICAgICAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG4gICAgICAgICAgICAvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJIb29rczoge1xuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGVsZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBuYW1lLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuXG4gICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuICAgICAgICAgICAgICAgIGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cbiAgICAgICAgICAgIGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgYm9vbEhvb2sgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcbiAgICAgICAgdmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG4gICAgICAgIGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcbiAgICAgICAgICAgIHZhciByZXQsIGhhbmRsZSxcbiAgICAgICAgICAgICAgICBsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoICFpc1hNTCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG4gICAgICAgICAgICAgICAgYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuICAgICAgICAgICAgICAgIHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgbG93ZXJjYXNlTmFtZSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9ICk7XG5cblxuXG5cbiAgICB2YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG4gICAgICAgIHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgcHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIHJldCwgaG9va3MsXG4gICAgICAgICAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG4gICAgICAgICAgICBpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG4gICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuICAgICAgICAgICAgICAgICAgICAoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbVsgbmFtZSBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByb3BIb29rczoge1xuICAgICAgICAgICAgdGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3MilcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YWJpbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICByZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaHJlZlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwcm9wRml4OiB7XG4gICAgICAgICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG4gICAgaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcbiAgICAgICAgalF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAgICAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoIHBhcmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgalF1ZXJ5LmVhY2goIFtcbiAgICAgICAgXCJ0YWJJbmRleFwiLFxuICAgICAgICBcInJlYWRPbmx5XCIsXG4gICAgICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgICAgIFwiY2VsbFNwYWNpbmdcIixcbiAgICAgICAgXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICBcInJvd1NwYW5cIixcbiAgICAgICAgXCJjb2xTcGFuXCIsXG4gICAgICAgIFwidXNlTWFwXCIsXG4gICAgICAgIFwiZnJhbWVCb3JkZXJcIixcbiAgICAgICAgXCJjb250ZW50RWRpdGFibGVcIlxuICAgIF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICBqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xuICAgIH0gKTtcblxuXG5cblxuICAgIC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcbiAgICAvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2VcbiAgICBmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcbiAgICAgICAgdmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG4gICAgICAgIHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuICAgICAgICAgICAgaWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cbiAgICAgICAgICAgIGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuICAgICAgICAgICAgICAgICAgICBjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVWYWxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IGpRdWVyeSggdGhpcyApO1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY2xhc3NOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSwgZWxlbSxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuICAgICAgICAgICAgd2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG5cblxuICAgIHZhciBycmV0dXJuID0gL1xcci9nO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICB2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIDAgXTtcblxuICAgICAgICAgICAgaWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcImdldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGVsZW0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAoIHZhbCA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG4gICAgICAgICAgICAgICAgaWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgdmFsSG9va3M6IHtcbiAgICAgICAgICAgIG9wdGlvbjoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUsIG9wdGlvbiwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluZGV4IDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXg7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBvbmUgPyBpbmRleCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhb3B0aW9uLmRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW9wdGlvblNldCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxuICAgIGpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICBqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcbiAgICAgICAgICAgIGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbiAgICBzdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4gICAgdmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuICAgICAgICBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG4gICAgICAgICAgICB2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcbiAgICAgICAgICAgICAgICBldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcbiAgICAgICAgICAgICAgICB0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG4gICAgICAgICAgICBjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgICAvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcbiAgICAgICAgICAgIGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLnNvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG4gICAgICAgICAgICBldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cbiAgICAgICAgICAgICAgICBldmVudCA6XG4gICAgICAgICAgICAgICAgbmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcbiAgICAgICAgICAgIGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuICAgICAgICAgICAgZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuICAgICAgICAgICAgZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG4gICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGVsZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3RcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhID09IG51bGwgP1xuICAgICAgICAgICAgICAgIFsgZXZlbnQgXSA6XG4gICAgICAgICAgICAgICAgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cbiAgICAgICAgICAgIC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcbiAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcbiAgICAgICAgICAgIC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG4gICAgICAgICAgICBpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cbiAgICAgICAgICAgICAgICBidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IGN1cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcbiAgICAgICAgICAgICAgICBpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gY3VyO1xuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBpID4gMSA/XG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZVR5cGUgOlxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkgaGFuZGxlclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOYXRpdmUgaGFuZGxlclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuICAgICAgICAgICAgICAgIGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICAvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG4gICAgICAgICAgICBpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG4gICAgICAgICAgICAgICAgICAgIGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0bXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgb250eXBlIF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyB0eXBlIF0oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdG1wICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIG9udHlwZSBdID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuICAgICAgICAvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuICAgICAgICBzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuICAgICAgICAgICAgdmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuICAgICAgICAgICAgICAgIG5ldyBqUXVlcnkuRXZlbnQoKSxcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2ltdWxhdGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcbiAgICAgICAgfVxuXG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWyAwIF07XG4gICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG4gICAgaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuICAgICAgICBqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuICAgICAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhYXR0YWNoZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhYXR0YWNoZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApO1xuICAgIH1cbiAgICB2YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbiAgICB2YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG4gICAgdmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbiAgICBqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgdmFyIHhtbDtcbiAgICAgICAgaWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcbiAgICAgICAgLy8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgIHhtbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhtbDtcbiAgICB9O1xuXG5cbiAgICB2YXJcbiAgICAgICAgcmJyYWNrZXQgPSAvXFxbXFxdJC8sXG4gICAgICAgIHJDUkxGID0gL1xccj9cXG4vZyxcbiAgICAgICAgcnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuICAgICAgICByc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICBmdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG4gICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuICAgICAgICAgICAgalF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICAgICAgICAgIGFkZCggcHJlZml4LCB2ICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhZGl0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb2JqICkge1xuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICAgICAgICBhZGQoIHByZWZpeCwgb2JqICk7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbiAgICBqUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG4gICAgICAgIHZhciBwcmVmaXgsXG4gICAgICAgICAgICBzID0gW10sXG4gICAgICAgICAgICBhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZU9yRnVuY3Rpb24oKSA6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlT3JGdW5jdGlvbjtcblxuICAgICAgICAgICAgICAgIHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKCBhID09IG51bGwgKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG4gICAgICAgICAgICBqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuICAgICAgICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG4gICAgICAgICAgICBmb3IgKCBwcmVmaXggaW4gYSApIHtcbiAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuICAgICAgICByZXR1cm4gcy5qb2luKCBcIiZcIiApO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG4gICAgICAgICAgICB9IClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcbiAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgICAgICAubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuICAgICAgICAgICAgICAgIH0gKS5nZXQoKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4gICAgdmFyXG4gICAgICAgIHIyMCA9IC8lMjAvZyxcbiAgICAgICAgcmhhc2ggPSAvIy4qJC8sXG4gICAgICAgIHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG4gICAgICAgIHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuICAgICAgICAvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cbiAgICAgICAgcmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcbiAgICAgICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG4gICAgICAgIHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuICAgICAgICAvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG4gICAgICAgIHByZWZpbHRlcnMgPSB7fSxcblxuICAgICAgICAvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG4gICAgICAgIHRyYW5zcG9ydHMgPSB7fSxcblxuICAgICAgICAvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cbiAgICAgICAgYWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG4gICAgICAgIC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuICAgICAgICBvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuICAgIG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuICAgIGZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG4gICAgICAgIC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbiAgICBmdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB7fSxcbiAgICAgICAgICAgIHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgICAgaW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG4gICAgICAgICAgICAgICAgICAgIGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbiAgICB9XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG4gICAgZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG4gICAgICAgIHZhciBrZXksIGRlZXAsXG4gICAgICAgICAgICBmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cbiAgICAgICAgZm9yICgga2V5IGluIHNyYyApIHtcbiAgICAgICAgICAgIGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBkZWVwICkge1xuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuICAgIGZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cbiAgICAgICAgdmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuICAgICAgICAgICAgY29udGVudHMgPSBzLmNvbnRlbnRzLFxuICAgICAgICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgd2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG4gICAgICAgICAgICBkYXRhVHlwZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuICAgICAgICBpZiAoIGN0ICkge1xuICAgICAgICAgICAgZm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcbiAgICAgICAgaWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG4gICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgICAgIGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoICFmaXJzdERhdGFUeXBlICkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdERhdGFUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuICAgICAgICAgICAgZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcbiAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICAgICAgICBpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG4gICAgICAgICAgICBpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuICAgIGZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcbiAgICAgICAgdmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG4gICAgICAgICAgICBjb252ZXJ0ZXJzID0ge30sXG5cbiAgICAgICAgICAgIC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cbiAgICAgICAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG4gICAgICAgIGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG4gICAgICAgICAgICBmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG4gICAgICAgIHdoaWxlICggY3VycmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG4gICAgICAgICAgICAgICAganFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgICAgICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICBpZiAoIGN1cnJlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG4gICAgICAgICAgICAgICAgaWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcHJldjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFjb252ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbnYgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29udiA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRtcFsgMCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ICE9PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoIHtcblxuICAgICAgICAvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcbiAgICAgICAgYWN0aXZlOiAwLFxuXG4gICAgICAgIC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3RcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB7fSxcbiAgICAgICAgZXRhZzoge30sXG5cbiAgICAgICAgYWpheFNldHRpbmdzOiB7XG4gICAgICAgICAgICB1cmw6IGxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgaXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcbiAgICAgICAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuICAgICAgICAgICAgLypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuICAgICAgICAgICAgYWNjZXB0czoge1xuICAgICAgICAgICAgICAgIFwiKlwiOiBhbGxUeXBlcyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgICAgICBodG1sOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgICAgIHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG4gICAgICAgICAgICAgICAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY29udGVudHM6IHtcbiAgICAgICAgICAgICAgICB4bWw6IC9cXGJ4bWxcXGIvLFxuICAgICAgICAgICAgICAgIGh0bWw6IC9cXGJodG1sLyxcbiAgICAgICAgICAgICAgICBqc29uOiAvXFxianNvblxcYi9cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc3BvbnNlRmllbGRzOiB7XG4gICAgICAgICAgICAgICAgeG1sOiBcInJlc3BvbnNlWE1MXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJyZXNwb25zZVRleHRcIixcbiAgICAgICAgICAgICAgICBqc29uOiBcInJlc3BvbnNlSlNPTlwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBEYXRhIGNvbnZlcnRlcnNcbiAgICAgICAgICAgIC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICAgIGNvbnZlcnRlcnM6IHtcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuICAgICAgICAgICAgICAgIFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuICAgICAgICAgICAgICAgIC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuICAgICAgICAgICAgICAgIFwidGV4dCBodG1sXCI6IHRydWUsXG5cbiAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRleHQgYXMgeG1sXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG4gICAgICAgICAgICAvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG4gICAgICAgICAgICAvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuICAgICAgICAgICAgLy8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG4gICAgICAgICAgICBmbGF0T3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHVybDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcbiAgICAgICAgLy8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuICAgICAgICAvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuICAgICAgICBhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzID9cblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAgICAgICAgYWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuICAgICAgICBhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuICAgICAgICAvLyBNYWluIG1ldGhvZFxuICAgICAgICBhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG4gICAgICAgICAgICAvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB1cmw7XG4gICAgICAgICAgICAgICAgdXJsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQsXG5cbiAgICAgICAgICAgICAgICAvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG4gICAgICAgICAgICAgICAgY2FjaGVVUkwsXG5cbiAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcblxuICAgICAgICAgICAgICAgIC8vIHRpbWVvdXQgaGFuZGxlXG4gICAgICAgICAgICAgICAgdGltZW91dFRpbWVyLFxuXG4gICAgICAgICAgICAgICAgLy8gVXJsIGNsZWFudXAgdmFyXG4gICAgICAgICAgICAgICAgdXJsQW5jaG9yLFxuXG4gICAgICAgICAgICAgICAgLy8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCxcblxuICAgICAgICAgICAgICAgIC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgICAgIGZpcmVHbG9iYWxzLFxuXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIGksXG5cbiAgICAgICAgICAgICAgICAvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcbiAgICAgICAgICAgICAgICB1bmNhY2hlZCxcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgICAgICBzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrcyBjb250ZXh0XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cbiAgICAgICAgICAgICAgICAvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgKCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudCxcblxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkc1xuICAgICAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG4gICAgICAgICAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVycyA9IHt9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuICAgICAgICAgICAgICAgIHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG4gICAgICAgICAgICAgICAgLy8gRmFrZSB4aHJcbiAgICAgICAgICAgICAgICBqcVhIUiA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlTdGF0ZTogMCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wbGV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KCBtYXRjaFsgMiBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJhdyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlcyB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5taW1lVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbXBsZXRlZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBjb2RlIGluIG1hcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0cmFuc3BvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggZGVmZXJyZWRzXG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG4gICAgICAgICAgICAvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcbiAgICAgICAgICAgIC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG4gICAgICAgICAgICAvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcbiAgICAgICAgICAgICAgICAucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG4gICAgICAgICAgICAvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcbiAgICAgICAgICAgIHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcbiAgICAgICAgICAgIHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG4gICAgICAgICAgICAvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cbiAgICAgICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG4gICAgICAgICAgICAgICAgLy8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcbiAgICAgICAgICAgICAgICAvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG4gICAgICAgICAgICAgICAgICAgIHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG4gICAgICAgICAgICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG4gICAgICAgICAgICBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgcy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgcHJlZmlsdGVyc1xuICAgICAgICAgICAgaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cbiAgICAgICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG4gICAgICAgICAgICBpZiAoIGNvbXBsZXRlZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG4gICAgICAgICAgICAvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuICAgICAgICAgICAgZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cbiAgICAgICAgICAgIC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcbiAgICAgICAgICAgIGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuICAgICAgICAgICAgcy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG4gICAgICAgICAgICBzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG4gICAgICAgICAgICAvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cbiAgICAgICAgICAgIC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuICAgICAgICAgICAgLy8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcbiAgICAgICAgICAgIGlmICggIXMuaGFzQ29udGVudCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuICAgICAgICAgICAgICAgIHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuICAgICAgICAgICAgICAgIGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcy5kYXRhO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuICAgICAgICAgICAgICAgICAgICB1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcbiAgICAgICAgICAgICAgICBzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG4gICAgICAgICAgICAgICAgKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgcy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cbiAgICAgICAgICAgIGlmICggcy5pZk1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG4gICAgICAgICAgICBpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcbiAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcbiAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICAgICAgICAgXCJBY2NlcHRcIixcbiAgICAgICAgICAgICAgICBzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cbiAgICAgICAgICAgICAgICAgICAgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuICAgICAgICAgICAgICAgICAgICAoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuICAgICAgICAgICAgICAgICAgICBzLmFjY2VwdHNbIFwiKlwiIF1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuICAgICAgICAgICAgZm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuICAgICAgICAgICAgaWYgKCBzLmJlZm9yZVNlbmQgJiZcbiAgICAgICAgICAgICAgICAoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSLmFib3J0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuICAgICAgICAgICAgc3RyQWJvcnQgPSBcImFib3J0XCI7XG5cbiAgICAgICAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcbiAgICAgICAgICAgIGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuICAgICAgICAgICAganFYSFIuZmFpbCggcy5lcnJvciApO1xuXG4gICAgICAgICAgICAvLyBHZXQgdHJhbnNwb3J0XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG4gICAgICAgICAgICBpZiAoICF0cmFuc3BvcnQgKSB7XG4gICAgICAgICAgICAgICAgZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBTZW5kIGdsb2JhbCBldmVudFxuICAgICAgICAgICAgICAgIGlmICggZmlyZUdsb2JhbHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG4gICAgICAgICAgICAgICAgaWYgKCBjb21wbGV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqcVhIUjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaW1lb3V0XG4gICAgICAgICAgICAgICAgaWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuICAgICAgICAgICAgICAgICAgICB9LCBzLnRpbWVvdXQgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbXBsZXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgZG9uZSggLTEsIGUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKCBjb21wbGV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAoIHRpbWVvdXRUaW1lciApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVhZHlTdGF0ZVxuICAgICAgICAgICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHJlc3BvbnNlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAoIHJlc3BvbnNlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuICAgICAgICAgICAgICAgIGlmICggaXNTdWNjZXNzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcy5pZk1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbW9kaWZpZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbW9kaWZpZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBtb2RpZmllZFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdWNjZXNzID0gIWVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0dXMgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzL0Vycm9yXG4gICAgICAgICAgICAgICAgaWYgKCBpc1N1Y2Nlc3MgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAganFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZpcmVHbG9iYWxzICkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29tcGxldGVcbiAgICAgICAgICAgICAgICBjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ganFYSFI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcbiAgICAgICAgalF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG4gICAgICAgICAgICAvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogY2FsbGJhY2tcbiAgICAgICAgICAgIH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuICAgICAgICB9O1xuICAgIH0gKTtcblxuXG4gICAgalF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KCB7XG4gICAgICAgICAgICB1cmw6IHVybCxcblxuICAgICAgICAgICAgLy8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgIGdsb2JhbDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG4gICAgICAgICAgICAvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuICAgICAgICAgICAgLy8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG4gICAgICAgICAgICBjb252ZXJ0ZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG4gICAgfTtcblxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICB3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIHZhciB3cmFwO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXNbIDAgXSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcbiAgICAgICAgICAgICAgICB3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuICAgICAgICAgICAgICAgIGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICAgICAgICAgIH0gKS5hcHBlbmQoIHRoaXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuICAgICAgICAgICAgICAgIGlmICggY29udGVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGVuZCggaHRtbCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4gICAgalF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgcmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbiAgICB9O1xuICAgIGpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICByZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xuICAgIH07XG5cblxuXG5cbiAgICBqUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfSBjYXRjaCAoIGUgKSB7fVxuICAgIH07XG5cbiAgICB2YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuICAgICAgICAgICAgLy8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcbiAgICAgICAgICAgIDA6IDIwMCxcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgICAgICAgIC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuICAgICAgICAgICAgMTIyMzogMjA0XG4gICAgICAgIH0sXG4gICAgICAgIHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbiAgICBzdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG4gICAgc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbiAgICBqUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgICAgIHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuICAgICAgICAvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG4gICAgICAgIGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhociA9IG9wdGlvbnMueGhyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYXN5bmMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXNzd29yZFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuICAgICAgICAgICAgICAgICAgICAvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSBpbiBoZWFkZXJzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gdG8gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcbiAgICAgICAgaWYgKCBzLmNyb3NzRG9tYWluICkge1xuICAgICAgICAgICAgcy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbiAgICBqUXVlcnkuYWpheFNldHVwKCB7XG4gICAgICAgIGFjY2VwdHM6IHtcbiAgICAgICAgICAgIHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcbiAgICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgICAgICBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0ZXJzOiB7XG4gICAgICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbiAgICBqUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG4gICAgICAgIGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgcy5jYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiApIHtcbiAgICAgICAgICAgIHMudHlwZSA9IFwiR0VUXCI7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICAvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuICAgICAgICBpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXZ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG5cblxuICAgIHZhciBvbGRDYWxsYmFja3MgPSBbXSxcbiAgICAgICAgcmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xuICAgIGpRdWVyeS5hamF4U2V0dXAoIHtcbiAgICAgICAganNvbnA6IFwiY2FsbGJhY2tcIixcbiAgICAgICAganNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcbiAgICAgICAgICAgIHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuICAgICAgICB2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG4gICAgICAgICAgICBqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuICAgICAgICAgICAgICAgICAgICBcInVybFwiIDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG4gICAgICAgIGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG4gICAgICAgICAgICAvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG4gICAgICAgICAgICBjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG4gICAgICAgICAgICAgICAgcy5qc29ucENhbGxiYWNrKCkgOlxuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaztcblxuICAgICAgICAgICAgLy8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuICAgICAgICAgICAgaWYgKCBqc29uUHJvcCApIHtcbiAgICAgICAgICAgICAgICBzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuICAgICAgICAgICAgcy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG4gICAgICAgICAgICBzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cbiAgICAgICAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tcbiAgICAgICAgICAgIG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcbiAgICAgICAgICAgIHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuICAgICAgICAgICAganFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgIGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTYXZlIGJhY2sgYXMgZnJlZVxuICAgICAgICAgICAgICAgIGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG4gICAgICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgICAgICAgICAgIG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgLy8gRGVsZWdhdGUgdG8gc2NyaXB0XG4gICAgICAgICAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG4gICAgc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG4gICAgICAgIGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuICAgICAgICByZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbiAgICB9ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG4gICAgalF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgIGtlZXBTY3JpcHRzID0gY29udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cbiAgICAgICAgaWYgKCAhY29udGV4dCApIHtcblxuICAgICAgICAgICAgLy8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuICAgICAgICAgICAgICAgIC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG4gICAgICAgICAgICAgICAgYmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcbiAgICAgICAgICAgICAgICBiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcbiAgICAgICAgc2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuICAgICAgICAvLyBTaW5nbGUgdGFnXG4gICAgICAgIGlmICggcGFyc2VkICkge1xuICAgICAgICAgICAgcmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG4gICAgICAgIGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICAgICAqL1xuICAgIGpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgb2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cbiAgICAgICAgaWYgKCBvZmYgPiAtMSApIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSBmdW5jdGlvblxuICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcbiAgICAgICAgfSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJQT1NUXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5hamF4KCB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgICAgICB9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5odG1sKCBzZWxlY3RvciA/XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG4gICAgICAgICAgICB9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG4gICAgalF1ZXJ5LmVhY2goIFtcbiAgICAgICAgXCJhamF4U3RhcnRcIixcbiAgICAgICAgXCJhamF4U3RvcFwiLFxuICAgICAgICBcImFqYXhDb21wbGV0ZVwiLFxuICAgICAgICBcImFqYXhFcnJvclwiLFxuICAgICAgICBcImFqYXhTdWNjZXNzXCIsXG4gICAgICAgIFwiYWpheFNlbmRcIlxuICAgIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuICAgICAgICBqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuICAgICAgICB9O1xuICAgIH0gKTtcblxuXG5cblxuICAgIGpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcbiAgICAgICAgfSApLmxlbmd0aDtcbiAgICB9O1xuXG5cblxuXG4gICAgalF1ZXJ5Lm9mZnNldCA9IHtcbiAgICAgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcbiAgICAgICAgICAgIHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcbiAgICAgICAgICAgICAgICBjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7fTtcblxuICAgICAgICAgICAgLy8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuICAgICAgICAgICAgY3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuICAgICAgICAgICAgY3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG4gICAgICAgICAgICBjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcbiAgICAgICAgICAgICAgICAoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG4gICAgICAgICAgICAvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcbiAgICAgICAgICAgIGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG4gICAgICAgICAgICAgICAgY3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgY3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgIGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG4gICAgICAgICAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcblxuICAgICAgICAvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cbiAgICAgICAgb2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICAgICAgICAgLy8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuICAgICAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlY3QsIHdpbixcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgMCBdO1xuXG4gICAgICAgICAgICBpZiAoICFlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAgICAgICAgIC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcbiAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuICAgICAgICAgICAgaWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuICAgICAgICAgICAgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG4gICAgICAgIC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoICF0aGlzWyAwIF0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgMCBdLFxuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuICAgICAgICAgICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG4gICAgICAgICAgICAgICAgKCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuICAgICAgICAvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcbiAgICAgICAgLy8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuICAgICAgICAvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuICAgICAgICAvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcbiAgICAgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG4gICAgalF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuICAgICAgICB2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG4gICAgICAgIGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG4gICAgICAgICAgICAgICAgdmFyIHdpbjtcbiAgICAgICAgICAgICAgICBpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbiA9IGVsZW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luID0gZWxlbS5kZWZhdWx0VmlldztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHdpbiApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbFRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgIXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcbiAgICAgICAgfTtcbiAgICB9ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbiAgICBqUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG4gICAgalF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuICAgICAgICBqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuICAgICAgICAgICAgICAgIC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuICAgICAgICAgICAgICAgIGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gKTtcbiAgICB9ICk7XG5cblxuICAgIGpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuICAgICAgICBcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcbiAgICAgICAgXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcbiAgICAgICAgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG4gICAgICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCBuYW1lICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cblxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cbiAgICAgICAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbiAgICBqUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG4gICAgICAgIHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG4gICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICB0bXAgPSBmblsgY29udGV4dCBdO1xuICAgICAgICAgICAgY29udGV4dCA9IGZuO1xuICAgICAgICAgICAgZm4gPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuICAgICAgICAvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICBpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbXVsYXRlZCBiaW5kXG4gICAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcbiAgICAgICAgcHJveHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICBwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgfTtcblxuICAgIGpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcbiAgICAgICAgaWYgKCBob2xkICkge1xuICAgICAgICAgICAgalF1ZXJ5LnJlYWR5V2FpdCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgalF1ZXJ5LnJlYWR5KCB0cnVlICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICBqUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbiAgICBqUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgICBqUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgalF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG4gICAgalF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBqUXVlcnkudHlwZSA9IHRvVHlwZTtcblxuICAgIGpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxuICAgIGpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAgIC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG4gICAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcbiAgICAgICAgLy8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2MilcbiAgICAgICAgdmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG4gICAgICAgIHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cbiAgICAgICAgICAgIC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuICAgICAgICAgICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgICAgICAgICAgLy8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG4gICAgICAgICAgICAhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG4gICAgfTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgICAgZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5O1xuICAgICAgICB9ICk7XG4gICAgfVxuXG5cblxuXG4gICAgdmFyXG5cbiAgICAgICAgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICAgIF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG4gICAgICAgIC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICAgIF8kID0gd2luZG93LiQ7XG5cbiAgICBqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuICAgICAgICBpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG4gICAgICAgICAgICB3aW5kb3cuJCA9IF8kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcbiAgICAgICAgICAgIHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICB9O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuICAgIGlmICggIW5vR2xvYmFsICkge1xuICAgICAgICB3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG4gICAgfVxuXG5cblxuXG4gICAgcmV0dXJuIGpRdWVyeTtcbn0gKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/jquery-3.4.1.js\n");

/***/ }),

/***/ 2:
/*!********************************************!*\
  !*** multi ./resources/js/jquery-3.4.1.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/miljan/laravel_practice/ibis_full_stack/resources/js/jquery-3.4.1.js */"./resources/js/jquery-3.4.1.js");


/***/ })

/******/ });